# Telloom Development Instructions

## Project Overview

Telloom is a web application that connects generations by preserving and sharing personal histories through video. As an expert full-stack developer, your task is to assist in building this app using the following tech stack:

- TypeScript
- Next.js 15 (with App Router and React Server Components)
- Prisma ORM
- Supabase for backend and authentication
- Mux for video handling
- Tailwind CSS
- Shadcn UI components
- Lucide icons
- Zod for validation
- RevenueCat for managing subscriptions
- React Hook Form for efficient form handling and validation
- Zustand for lightweight and flexible state management
- Framer Motion for animations and interactive UI elements
- Sonner for Toast notifications

## Core Principles

1. **Simplicity**: Provide clear, step-by-step instructions suitable for newcomers to coding.
2. **Best Practices**: Ensure code is optimized, maintainable, and follows industry standards.
3. **User-Centric Design**: Focus on creating an intuitive and responsive user interface.
4. **Maximize React Compatibility**: Whenever possible write code that is more compatible with React.
## Code Style and Structure

### TypeScript Usage

- Use TypeScript for all code
- Prefer interfaces over types

### Programming Patterns

- Use functional and declarative programming patterns
- Avoid classes; prefer functional components with TypeScript interfaces
- Prioritize iteration and modularization over code duplication

### Naming Conventions

- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`)
- Follow standard casing formats:
  - PascalCase for component names (e.g., `UserProfile`)
  - camelCase for variables and functions (e.g., `fetchData`)
  - kebab-case for directory and file names (e.g., `components/auth-wizard`)
  - UPPER_SNAKE_CASE for constants (e.g., `MAX_LIMIT`)

### Casing Standards

#### File & Directory Names
- **Component Files**: Use PascalCase for the file name to match the component name
  ```
  components/
  ├── UserProfile.tsx        ✓ Correct
  ├── userProfile.tsx        ✗ Incorrect
  └── user-profile.tsx       ✗ Incorrect
  ```

- **Directory Names**: Use kebab-case for all directories
  ```
  src/
  ├── components/
  │   ├── auth-wizard/       ✓ Correct
  │   ├── authWizard/       ✗ Incorrect
  │   └── AuthWizard/       ✗ Incorrect
  ```

- **Special Directories**: Next.js special directories should follow Next.js conventions
  ```
  app/
  ├── (authenticated)/      ✓ Correct (group directory)
  ├── [id]/                ✓ Correct (dynamic route)
  └── @modal/              ✓ Correct (parallel route)
  ```

#### Component Names
- **React Components**: Always PascalCase
  ```typescript
  // ✓ Correct
  export default function UserProfile() {}
  export const ButtonGroup = () => {}

  // ✗ Incorrect
  export default function userProfile() {}
  export const buttonGroup = () => {}
  ```

#### Variables & Functions
- **Variables**: camelCase
  ```typescript
  // ✓ Correct
  const userAge = 25;
  const isLoading = true;
  
  // ✗ Incorrect
  const UserAge = 25;
  const is_loading = true;
  ```

- **Functions**: camelCase
  ```typescript
  // ✓ Correct
  function calculateTotal() {}
  const handleSubmit = () => {}
  
  // ✗ Incorrect
  function CalculateTotal() {}
  const Handle_Submit = () => {}
  ```

#### Constants
- **Constants**: UPPER_SNAKE_CASE for true constants, camelCase for configuration objects
  ```typescript
  // ✓ Correct
  const MAX_RETRY_ATTEMPTS = 3;
  const API_ENDPOINT = '/api/v1';
  const defaultConfig = {
    timeout: 5000,
    retryCount: 3
  };
  
  // ✗ Incorrect
  const maxRetryAttempts = 3;
  const apiEndpoint = '/api/v1';
  const DEFAULT_CONFIG = {
    timeout: 5000,
    retryCount: 3
  };
  ```

#### Types & Interfaces
- **Types & Interfaces**: PascalCase
  ```typescript
  // ✓ Correct
  interface UserProfile {}
  type AuthState = {}
  
  // ✗ Incorrect
  interface userProfile {}
  type authState = {}
  ```

#### Component Props
- **Props**: camelCase for prop names, PascalCase for prop types
  ```typescript
  // ✓ Correct
  interface ButtonProps {
    isDisabled: boolean;
    onClick: () => void;
  }
  
  // ✗ Incorrect
  interface ButtonProps {
    IsDisabled: boolean;
    on_click: () => void;
  }
  ```

#### CSS Classes & Tailwind
- **Custom CSS Classes**: kebab-case
  ```css
  /* ✓ Correct */
  .user-profile {}
  .nav-link-active {}
  
  /* ✗ Incorrect */
  .userProfile {}
  .NavLinkActive {}
  ```

- **Tailwind Classes**: Follow Tailwind's conventions
  ```typescript
  // ✓ Correct
  className="text-sm md:text-base hover:bg-gray-100"
  
  // ✗ Incorrect
  className="TEXT_SM MD_TEXT_BASE HOVER_BG_GRAY_100"
  ```

#### Import Aliases
- **Import Aliases**: kebab-case for directories, match exact casing for files
  ```typescript
  // ✓ Correct
  import { Button } from '@/components/ui/Button';
  import { useAuth } from '@/lib/auth-utils';
  
  // ✗ Incorrect
  import { Button } from '@/Components/UI/button';
  import { useAuth } from '@/Lib/authUtils';
  ```

### File Structure

- Organize files with exported components, subcomponents, helpers, static content, and types
- Add a comment at the top of each file summarizing its purpose

```typescript
// auth-wizard.tsx
// This component handles user authentication flow

import React from 'react';
// ... rest of the code
```

## UI and Styling

- Use Tailwind CSS for styling
- Implement Shadcn UI components and Lucide icons
- Follow a mobile-first approach for responsive design
- Utilize Framer Motion for animations and interactive UI elements

```typescript
const Button = ({ children }) => (
  <button className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors">
    {children}
  </button>
);
```

### Mobile Input Field Guidelines

-   **Prevent Auto-Zoom on iOS Safari**: To avoid the automatic zoom-in behavior on iOS Safari when a user focuses on an input field, all text-based `<input>` elements, `<textarea>` elements, and `<select>` elements must have a `font-size` of at least `16px` when viewed on mobile devices.
    -   This can typically be achieved by applying a Tailwind CSS class like `text-[16px]` directly to the input elements for mobile views or by setting this font size in `globals.css` within a mobile-specific media query (e.g., `@media (max-width: 768px)`).
    -   Example: `className="text-[16px]"` or specific CSS `input { font-size: 16px !important; }` for mobile.

-   **Ensure Sufficient Input Width on Mobile**: Text input fields on mobile views should generally utilize the full available width of their parent container, allowing for minimal necessary padding. This provides an optimal and seamless typing experience.
    -   Use Tailwind CSS utility classes like `w-full` to make input fields span the width of their container.
    -   Ensure that the parent container itself has appropriate padding so the input field doesn't touch the screen edges directly.

-   **Compact Sizing on Mobile**: When optimizing text input forms for mobile, consider reducing the height and padding of input fields and associated buttons to create a more compact layout. For example, an input might go from `h-9 px-3` (desktop) to `h-8 px-2` (mobile), and a button from `h-9 px-4` (desktop) to `h-8 px-3` (mobile). Ensure these changes are responsive and revert to standard sizes on larger screens (e.g., using `md:` prefixes).

-   **Align with Parent Container Padding on Mobile**: When a form component is nested within a container (e.g., `CardContent`) that already defines horizontal padding, the form component's immediate wrapper should avoid adding its own horizontal padding on mobile. This ensures the form's input fields and buttons align with the text content of the parent container, creating a cleaner look. Vertical padding can still be applied within the form component for spacing between its elements.
    -   Example: If `CardContent` has `px-6`, the form wrapper inside it might use `py-4` on mobile (for vertical spacing) but omit `px-*`, relying on the parent's `px-6`. Responsive classes like `md:p-6` can be used to reintroduce padding on larger screens if needed for a different layout.

### Logo Standardization
- Always use the standardized dimensions for the Telloom logo:
  - Width: 160px
  - Height: 40px
  - Aspect ratio: 4:1
- Use the following pattern for all logo implementations:
  ```typescript
  <Image
    src="/images/Telloom Logo V1-Horizontal Green.png"
    alt="Telloom Logo"
    width={160}
    height={40}
    priority={true}
    style={{
      width: 'auto',
      height: 'auto',
      maxWidth: '160px'
    }}
  />
  ```
- This ensures consistent branding and prevents image dimension warnings

## Spacing Guidelines

### Global Content Wrapper
- Use the `container` class with `max-w-7xl` for main content areas
- Always include horizontal padding with `px-4` or `px-6`
- Include vertical padding with `py-6` or `py-8` for sections
- Center containers with `mx-auto`

### Spacing Scale
Follow a consistent 4px/8px spacing scale using Tailwind's spacing utilities:
- 4px (1): Minimal spacing (between tight elements)
- 8px (2): Small spacing (between related items)
- 16px (4): Medium spacing (between distinct elements)
- 24px (6): Large spacing (between sections)
- 32px (8): Extra large spacing (major sections)

### Component Spacing
- Cards/Modules:
  ```typescript
  // ✓ Correct - Consistent internal padding
  <Card className="p-6 md:p-8">
  
  // ✗ Incorrect - Inconsistent or missing padding
  <Card className="pt-4 pb-2 px-3">
  ```

- Lists and Grids:
  ```typescript
  // ✓ Correct - Consistent gaps
  <div className="grid gap-6 md:grid-cols-2">
  
  // ✗ Incorrect - Inconsistent spacing
  <div className="grid gap-3 md:gap-5">
  ```

### Responsive Spacing
- Use smaller spacing on mobile:
  ```typescript
  // ✓ Correct - Responsive padding
  className="p-4 md:p-6 lg:p-8"
  
  // ✗ Incorrect - Fixed padding
  className="p-8"
  ```

- Scale margins at breakpoints:
  ```typescript
  // ✓ Correct - Responsive margins
  className="mb-4 md:mb-6 lg:mb-8"
  
  // ✗ Incorrect - No responsive scaling
  className="mb-8"
  ```

### Visual Hierarchy
- Use consistent spacing between related elements:
  ```typescript
  // ✓ Correct - Consistent hierarchy
  <div className="space-y-2">  {/* tight grouping */}
    <Label>Name</Label>
    <Input />
  </div>
  <div className="space-y-4">  {/* related fields */}
    <FormField />
    <FormField />
  </div>
  <div className="space-y-8">  {/* distinct sections */}
    <Section />
    <Section />
  </div>
  ```

### Best Practices
- Always wrap main content in a container with edge padding
- Use consistent spacing within similar components
- Scale spacing at responsive breakpoints
- Use space-y-{size} for consistent vertical spacing
- Add larger spacing between major sections
- Ensure text and interactive elements have adequate padding
- Test layouts across different screen sizes

## Backend and Authentication

- Utilize Supabase for backend services and SSR authentication (NEVER use Supabase Auth Helpers - it's deprecated)
- Use Prisma ORM for database interactions
- Ensure database models align with Prisma schema

## Video Handling

- Implement Mux for video uploading, processing, and playback
- Integrate AI-powered transcription features as needed

## Subscription Management

- Use RevenueCat to manage user subscriptions

## State Management and Data Fetching

- Implement modern state management solutions (e.g., Zustand, React Query)
- Use Zod for data validation

```typescript
import { z } from 'zod';

const userSchema = z.object({
  id: z.string(),
  name: z.string().min(2),
  email: z.string().email(),
});

type User = z.infer<typeof userSchema>;
```

## Optimization and Best Practices

- Minimize use of 'use client', useEffect, and setState
- Favor React Server Components and Next.js SSR features
- Implement dynamic imports for code splitting
- Optimize images: use WebP format, include size data, implement lazy loading
- Focus on improving Web Vitals (LCP, CLS, FID)

## Error Handling and Validation

- Prioritize error handling and edge cases
- Use early returns and guard clauses
- Implement custom error types for consistent handling

```typescript
function processUserData(user: User | null): string {
  if (!user) {
    throw new Error('User data is missing');
  }

  if (!user.name) {
    return 'Anonymous';
  }

  return user.name.toUpperCase();
}
```

## Security and Performance

- Follow performance optimization techniques
- Ensure secure handling of user data and authentication flows

## Testing and Documentation

- Write unit tests using Jest and React Testing Library
- Provide clear comments for complex logic
- Use JSDoc comments for improved IDE IntelliSense

```typescript
/**
 * Formats a user's full name.
 * @param {string} firstName - The user's first name
 * @param {string} lastName - The user's last name
 * @returns {string} The formatted full name
 */
function formatFullName(firstName: string, lastName: string): string {
  return `${firstName} ${lastName}`.trim();
}
```

## Development Process

1. **Analysis**: Understand the task and its requirements by thinking step by step from first principles. Make a plan and consider where it might be going wrong contextually. Never be lazy in this process.
2. **Planning**: Outline the steps needed to accomplish the task, ensuring a thorough and thoughtful approach.
3. **Implementation**: Provide step-by-step guidance, maintaining clarity and precision.
4. **Review and Optimize**: Suggest potential improvements, considering both the current context and possible future challenges.
5. **Finalization**: Ensure the solution meets all requirements and best practices, with a focus on thoroughness and attention to detail.

Remember to approach each task with analytical rigor, break down problems into smaller parts, and consider multiple solutions before implementation. Always prioritize creating a supportive learning experience for newcomers to coding.

## Styling Guidelines

### Colors and Theme

- Primary brand colors:
  - Primary Green: `#1B4332` (dark green for primary actions and borders)
  - Secondary Green: `#8fbc55` (lighter green for hover states and shadows)
  - Use these consistently for brand identity

### Component Styling

- Card styling pattern:
  ```typescript
  className="border-2 border-[#1B4332] shadow-[6px_6px_0_0_#8fbc55] hover:shadow-[8px_8px_0_0_#8fbc55] transition-all duration-300"
  ```

- Button variants:
  - Primary: Dark green background with white text
  - Secondary: White background with dark green border
  - Ghost: Transparent with hover states
  - Always use rounded-full for buttons: `className="rounded-full"`

### Hover and Interactive States

- Use transition-all with duration-300 for smooth interactions
- Implement hover:bg-[#8fbc55] for interactive elements
- Use hover:text-[#1B4332] for text color changes on hover

### Layout and Spacing

- Use consistent spacing with Tailwind's spacing scale
- Maintain padding hierarchy:
  - Cards: p-4 to p-6
  - Buttons: px-4 py-2
  - Container margins: m-4
- Use flex and grid layouts appropriately:
  - flex for single-dimension layouts
  - grid for two-dimensional layouts

### Responsive Design

- Use mobile-first approach with Tailwind breakpoints
- Common pattern:
  ```typescript
  className="text-sm md:text-base lg:text-lg"
  ```
- Stack elements vertically on mobile, horizontally on desktop:
  ```typescript
  className="flex flex-col md:flex-row"
  ```

### Typography

- Use consistent font sizes:
  - Headings: text-xl to text-3xl
  - Body: text-sm to text-base
  - Labels: text-xs to text-sm
- Use font-semibold for headings and important text
- Use text-muted-foreground for secondary text

### Shadows and Depth

- Use consistent shadow patterns:
  ```typescript
  shadow-[6px_6px_0_0_#8fbc55]
  ```
- Increase shadow on hover for interactive elements

### Forms and Inputs

- Use consistent input styling:
  ```typescript
  className="border-2 border-gray-200 rounded-lg focus-visible:ring-[#8fbc55]"
  ```
- Always include proper labels and helper text
- Use consistent padding and spacing

### Loading States

- Use Loader2 component with animate-spin
- Maintain consistent loading state visuals:
  ```typescript
  className="h-8 w-8 animate-spin text-gray-400"
  ```

### Error States

- Use red-500 for error states
- Provide clear error messages
- Use toast notifications for feedback

### Accessibility

- Maintain proper contrast ratios
- Include proper ARIA labels
- Ensure keyboard navigation works
- Use semantic HTML elements

## Dynamic Styles with CSS Custom Properties

When dealing with dynamic inline styles in React components that change based on JavaScript variables (e.g., progress bars, audio visualizers), prefer using CSS Custom Properties (CSS Variables) over directly manipulating the `style` attribute with JavaScript string templates for properties like `width` or `height` expressed in percentages or other units.

**Rationale:**
- **Separation of Concerns**: Keeps styling logic primarily within CSS files, making components cleaner.
- **Performance**: Potentially better performance as the browser can optimize CSS variable changes more effectively than direct style manipulations in some cases.
- **Maintainability**: Easier to manage and update styles from a central CSS location.
- **Linter Compliance**: Helps avoid "no-inline-styles" linter warnings without needing to disable the rule.

**Pattern:**

1.  **In your component (`.tsx` file):**
    *   Add a `useRef` to the HTML element whose style needs to be dynamic.
    *   Use a `useEffect` hook that listens to changes in the relevant JavaScript variable(s).
    *   Inside the `useEffect`, update the CSS custom property on the referenced element: `elementRef.current.style.setProperty('--my-dynamic-width', `${value}%`);`
    *   Assign a dedicated CSS class to the element instead of using an inline `style` for the dynamic property.

    ```typescript
    // ExampleComponent.tsx
    import React, { useEffect, useRef, useState } from 'react';
    import './ExampleComponent.css'; // Or your module.css

    const ExampleComponent = () => {
      const [progress, setProgress] = useState(0);
      const progressBarRef = useRef<HTMLDivElement>(null);

      useEffect(() => {
        if (progressBarRef.current) {
          progressBarRef.current.style.setProperty('--progress-width', `${progress}%`);
        }
      }, [progress]);

      // Simulate progress update
      useEffect(() => {
        const timer = setInterval(() => {
          setProgress(prev => (prev >= 100 ? 0 : prev + 10));
        }, 1000);
        return () => clearInterval(timer);
      }, []);

      return (
        <div className="progress-bar-container">
          <div ref={progressBarRef} className="progress-bar-inner">
            {progress}%
          </div>
        </div>
      );
    };

    export default ExampleComponent;
    ```

2.  **In your CSS file (`.css` or `.module.css`):**
    *   Define the style for the dedicated class, using the CSS custom property with a fallback value.

    ```css
    /* ExampleComponent.css or styles.module.css */
    .progress-bar-container {
      width: 100%;
      background-color: #e0e0e0;
      border-radius: 4px;
      padding: 2px;
    }

    .progress-bar-inner {
      height: 20px;
      background-color: #4caf50; /* Or your brand color */
      color: white;
      text-align: center;
      line-height: 20px;
      border-radius: 2px;
      transition: width 0.3s ease-in-out; /* Optional: for smooth transitions */
      width: var(--progress-width, 0%); /* Use the CSS variable */
    }
    ```

This approach provides a clean, maintainable, and linter-friendly way to handle dynamic styles derived from component state or props.

## Dynamic Route Parameters in Next.js Server Components

When working with dynamic route parameters in Next.js server components (e.g., [id] folders), follow these rules to properly handle the params object:

### 1. Make Layout Components Async

```typescript
export default async function DynamicLayout(props: Props) {
  const resolvedParams = await Promise.resolve(props.params);
  // ... use resolvedParams
}
```

### 2. Resolve Params Before Use

```typescript
// ✅ CORRECT: Await params before accessing properties
const resolvedParams = await Promise.resolve(params);
const id = resolvedParams.id;

// ❌ INCORRECT: Directly accessing params properties
const id = params.id; // Will cause warning
```

### 3. Pass Resolved Params to Children

```typescript
// ✅ CORRECT: Pass resolved params
<ChildComponent params={resolvedParams} />

// ❌ INCORRECT: Pass raw params
<ChildComponent params={params} />
```

### 4. Type Params Properly

```typescript
interface Props {
  params: {
    id: string;
    // Add other dynamic segments as needed
  };
}
```

### 5. Handle Params in Content Components

```typescript
async function PageContent({ params }: Props) {
  // Always resolve params first
  const resolvedParams = await Promise.resolve(params);
  const id = resolvedParams.id;
  
  // Use resolved value in queries/logic
  const { data } = await supabase
    .from('Table')
    .eq('id', id)
    .single();
}
```

## Common Patterns for Dynamic Routes

### 1. Layout Pattern

```typescript
export default async function Layout({ params, children }: Props) {
  const resolvedParams = await Promise.resolve(params);
  
  return (
    <Suspense fallback={<Loading />}>
      <LayoutContent params={resolvedParams}>
        {children}
      </LayoutContent>
    </Suspense>
  );
}
```

### 2. Page Pattern

```typescript
export default async function Page({ params }: Props) {
  const resolvedParams = await Promise.resolve(params);
  const id = resolvedParams.id;
  
  return (
    <Suspense fallback={<Loading />}>
      <PageContent id={id} />
    </Suspense>
  );
}
```

## Best Practices

1. Always use async/await with params
2. Resolve params at the earliest possible point
3. Pass resolved values down instead of raw params
4. Use consistent naming (resolvedParams) for clarity
5. Add proper TypeScript interfaces for params
6. Include error boundaries and loading states
7. Log resolved params for debugging

## Debugging Tips

```typescript
// Add debug logs to track params resolution
console.log('[DEBUG] Starting execution with params:', { resolvedParams });

// Use try/catch when resolving params
try {
  const resolvedParams = await Promise.resolve(params);
} catch (error) {
  console.error('Error resolving params:', error);
  notFound();
}
```

## Common Issues and Solutions

- **Issue 1: Params Promise Warning**  
  Solution: Always await Promise.resolve(params)

- **Issue 2: Undefined Properties**  
  Solution: Add proper TypeScript interfaces and null checks

- **Issue 3: Race Conditions**  
  Solution: Resolve params before any dependent operations

- **Issue 4: Client/Server Mismatch**  
  Solution: Use proper 'use client' directives and keep params handling server-side

## Centralized Helper Functions & JWT-Based Access Control

To provide a consistent and centralized way of managing permissions throughout Telloom's database access and application logic, we rely on a set of helper functions that use JWT values and database role data. These functions include but are not limited to:

- **`public.has_sharer_access(sharer_id uuid)`**  
  Checks whether the current user (via `auth.uid()`) is the owner of the sharer profile or an executor assigned to that sharer.

- **`public.has_listener_access(sharer_id uuid)`**  
  Checks whether the current user is an approved listener for a given sharer (by verifying that an entry exists in the ProfileListener table with hasAccess = true).

- **`public.is_admin()`** (or its overload with a user ID)  
  Returns true if the current user is an administrator. The function inspects the JWT claims (via `auth.jwt()`) and/or the metadata in the auth.users table (such as the "role" key or the is_super_admin flag).

- **JWT Functions:**  
  Functions like `auth.uid()`, `auth.role()`, `get_sharer_id_from_jwt()`, and `is_sharer_from_jwt()` extract values directly from the signed JWT claims. This ensures that the access logic is based on a central source of truth.

### How to Use These Helper Functions

#### In RLS Policies:

Every RLS policy uses these helper functions in its USING and WITH CHECK clauses. For example, a policy for selecting a prompt response might include:

```sql
USING ( is_admin() OR has_sharer_access("profileSharerId") OR has_listener_access("profileSharerId") )
```

This pattern ensures that if the user is an admin, has sharer or executor access, or is an approved listener, then the operation is allowed.

#### In Application Code:

When fetching data (e.g., via Supabase RPC calls), the app should use JWT-based helper functions to determine the current user's role and permissions, for example:

```typescript
const { data, error } = await supabase.rpc('get_executor_for_user', { user_id: user.id });
const hasAccess = data?.executor_relationships?.some(rel => rel.sharerId === sharerId);
```

Similarly, UI components should use these centralized checks to conditionally render content.

### Benefits:

- **Consistency:** Changing access rules now only requires updating the helper functions.
- **Security:** Centralized, JWT-driven access logic ensures a single trusted source controls permissions.
- **Maintainability:** Reduces duplicated code and keeps role-check logic isolated from business logic.

## Role-Based Routes in Next.js Implementation

When implementing role-based routes in the Telloom application, follow these patterns to ensure proper access control and data flow:

### 1. Role Selection Flow

```
/select-role → /role-executor → /role-executor/[id]
```

- Use a dedicated route for role selection when users have multiple roles
- Store selected role in cookies for persistence across sessions
- Implement proper redirects based on available roles

### 2. Role-Specific Components Structure

For each role (SHARER, EXECUTOR, LISTENER), establish a consistent component structure:

```
/app/(authenticated)/
  ├── role-executor/                # Main executor dashboard listing all sharers
  │   ├── page.tsx                  # Lists all sharers for which user is executor
  │   └── [id]/                     # Dynamic routes for specific sharer management
  │       ├── page.tsx              # Sharer-specific dashboard for executor
  │       ├── layout.tsx            # Layout with access control for this sharer
  │       └── topics/               # Content management for this sharer
  │
  ├── role-sharer/                  # Content creation, invitations, settings
  │   └── page.tsx
  │
  └── role-listener/                # Content viewing and interactions
      └── page.tsx
```

### 3. Access Validation in Layout Components

- Place access control logic in layout.tsx files for each role-specific section
- Use RPC functions (which use the central helper functions) to verify permissions:

```typescript
// role-executor/[id]/layout.tsx
export default async function ExecutorSharerLayout({ params, children }: Props) {
  const resolvedParams = await Promise.resolve(params);
  const sharerId = resolvedParams.id;
  
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();
  
  // Validate executor relationship with this sharer using RPC which internally uses has_sharer_access() helper
  const { data, error } = await supabase.rpc(
    'get_executor_for_user',
    { user_id: user.id }
  );
  
  // Check if user has relationship with this sharer
  const hasAccess = data?.executor_relationships?.some(
    (rel: any) => rel.sharerId === sharerId
  );
  
  if (!hasAccess) {
    redirect('/role-executor');
  }
  
  return <>{children}</>;
}
```

### 4. Content Page Implementation

- In page.tsx components, focus on data fetching and presentation
- Use RPC functions to avoid direct RLS pitfalls and leverage JWT-based helper functions:

```typescript
// role-executor/page.tsx
async function RoleExecutorPageContent() {
  const supabase = createClient();
  const { data: { user } } = await supabase.auth.getUser();

  // Get relationships using RPC function
  const { data: executorData } = await supabase.rpc(
    'get_executor_for_user', 
    { user_id: user.id }
  );
  
  const relationships = executorData?.executor_relationships || [];
  
  // Render relationships list
  return (
    <div>
      {relationships.map(relationship => (
        <ExecutorSharingCard key={relationship.id} executorRelationship={relationship} />
      ))}
    </div>
  );
}
```

### 5. Role Transition Handling

When users switch between roles:

- Set a role transition flag for smooth UI transitions
- Update cookies to persist the new role
- Clear the flag after navigation completes

```typescript
// In role selection component
async function handleRoleSelection(role: string) {
  setIsRoleTransition(true);
  await setRoleCookie(role);
  router.push(`/role-${role.toLowerCase()}`);
}

// In listener component after navigation completes
useEffect(() => {
  clearRoleTransition();
}, []);
```

### 6. Development Guidelines for Roles

- Keep each role's functionality in its dedicated directory structure
- Use shared components for common UI elements
- Place RPC function definitions in SQL migration files
- Document all database functions with clear comments
- Test role transitions thoroughly with multiple user scenarios

## Supabase Authentication and Client Creation in Next.js

When working with Supabase in the Telloom app, follow these guidelines to ensure proper authentication and client creation:

### 1. Server-Side Client Creation

For server components, always use the server-side client creation approach:

```typescript
// utils/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

export function createClient() {
  const cookieStore = cookies();
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name) {
          return cookieStore.get(name)?.value;
        },
        set(name, value, options) {
          cookieStore.set({ name, value, ...options });
        },
        remove(name, options) {
          cookieStore.set({ name, value: '', ...options });
        },
      },
    }
  );
}
```

### 2. Client-Side Client Creation

For client components, use the client-side approach:

```typescript
// utils/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
```

### 3. Authentication in Server Components

In server components, always get the user like this:

```typescript
// In a server component (.tsx/.jsx file)
import { createClient } from '@/utils/supabase/server';

export default async function ServerComponent() {
  const supabase = createClient();
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error || !user) {
    redirect('/login');
  }
  
  // Continue with authenticated logic
}
```

### 4. IMPORTANT: NEVER USE SUPABASE AUTH HELPERS

Supabase Auth Helpers package is deprecated and should NEVER be used. Instead:

- ✅ Use `createServerClient` from '@supabase/ssr' for server components
- ✅ Use `createBrowserClient` from '@supabase/ssr' for client components
- ❌ Never import or use anything from '@supabase/auth-helpers-*'

### 5. Access Control Patterns

- For public pages, allow anonymous access
- For authenticated pages, verify user exists
- For role-specific pages, verify user role

```typescript
// Role verification in server component
const { data } = await supabase
  .from('ProfileRole')
  .select('role')
  .eq('profileId', user.id);

const hasRole = data?.some(role => role.role === 'EXECUTOR');
if (!hasRole) {
  redirect('/select-role');
}
```

### 6. Error Handling for Authentication

Always include proper error handling for authentication failures:

```typescript
try {
  const { data: { user }, error } = await supabase.auth.getUser();
  
  if (error) {
    console.error('Authentication error:', error.message);
    redirect('/login?error=auth_failed');
  }
  
  if (!user) {
    redirect('/login');
  }
} catch (error) {
  console.error('Unexpected authentication error:', error);
  redirect('/login?error=unexpected');
}
```

## Summary of Updates Based on Helper Functions and JWT

- **Centralized Access & JWT Usage:**  
  All table-level policies should leverage helper functions (e.g., `has_sharer_access()`, `has_listener_access()`, `is_admin()`) that use JWT data via functions such as `auth.uid()` and `auth.jwt()`. This centralization ensures that changes to role definitions or access rules are made only in one place.

- **Consistent Use of JWT Claims:**  
  Database functions such as `get_sharer_id_from_jwt()` and `is_sharer_from_jwt()` provide consistent extraction of JWT claims. Update your RLS policies and application code to utilize these functions for role-based access control.

- **Base Tables and Access Patterns:**
  The foundation tables (`ProfileSharer`, `ProfileExecutor`, etc.) should use direct checks rather than composite helper functions to avoid potential infinite recursion issues.

- **RPC Functions for Complex Queries:**
  Use RPC functions with `SECURITY DEFINER` for complex relationship queries to bypass RLS safely while maintaining security boundaries.

## SQL Function Storage

When using MCP to create or modify SQL functions, ensure the full SQL definition is saved to a file in the `supabase/mcp_functions/` directory. Name the file descriptively, e.g., `get_listener_topic_prompts_and_responses.sql`.
