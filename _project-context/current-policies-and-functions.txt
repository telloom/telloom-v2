[
  {
    "table_name": "Entitlement",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Entitlement",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Entitlement",
    "column_name": "lookupKey",
    "data_type": "text"
  },
  {
    "table_name": "Entitlement",
    "column_name": "displayName",
    "data_type": "text"
  },
  {
    "table_name": "Entitlement",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Entitlement",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "requestorId",
    "data_type": "uuid"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "status",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "approvedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "FollowRequest",
    "column_name": "deniedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Invitation",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Invitation",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "Invitation",
    "column_name": "inviterId",
    "data_type": "uuid"
  },
  {
    "table_name": "Invitation",
    "column_name": "inviteeEmail",
    "data_type": "text"
  },
  {
    "table_name": "Invitation",
    "column_name": "role",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "Invitation",
    "column_name": "status",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "Invitation",
    "column_name": "token",
    "data_type": "text"
  },
  {
    "table_name": "Invitation",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Invitation",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Invitation",
    "column_name": "acceptedAt",
    "data_type": "timestamp without time zone"
  },
  {
    "table_name": "Invitation",
    "column_name": "executorFirstName",
    "data_type": "text"
  },
  {
    "table_name": "Invitation",
    "column_name": "executorLastName",
    "data_type": "text"
  },
  {
    "table_name": "Invitation",
    "column_name": "executorRelation",
    "data_type": "text"
  },
  {
    "table_name": "Invitation",
    "column_name": "executorPhone",
    "data_type": "text"
  },
  {
    "table_name": "Notification",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Notification",
    "column_name": "userId",
    "data_type": "uuid"
  },
  {
    "table_name": "Notification",
    "column_name": "type",
    "data_type": "text"
  },
  {
    "table_name": "Notification",
    "column_name": "message",
    "data_type": "text"
  },
  {
    "table_name": "Notification",
    "column_name": "data",
    "data_type": "jsonb"
  },
  {
    "table_name": "Notification",
    "column_name": "isRead",
    "data_type": "boolean"
  },
  {
    "table_name": "Notification",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Notification",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Object",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Object",
    "column_name": "userId",
    "data_type": "uuid"
  },
  {
    "table_name": "Object",
    "column_name": "objectName",
    "data_type": "text"
  },
  {
    "table_name": "Object",
    "column_name": "objectDescription",
    "data_type": "text"
  },
  {
    "table_name": "Object",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "Object",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Object",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Object",
    "column_name": "promptResponseId",
    "data_type": "uuid"
  },
  {
    "table_name": "Object",
    "column_name": "categoryId",
    "data_type": "uuid"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "categoryName",
    "data_type": "text"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "description",
    "data_type": "text"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ObjectCategory",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Offering",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Offering",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Offering",
    "column_name": "lookupKey",
    "data_type": "text"
  },
  {
    "table_name": "Offering",
    "column_name": "displayName",
    "data_type": "text"
  },
  {
    "table_name": "Offering",
    "column_name": "isCurrent",
    "data_type": "boolean"
  },
  {
    "table_name": "Offering",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Offering",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Package",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Package",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Package",
    "column_name": "offeringId",
    "data_type": "uuid"
  },
  {
    "table_name": "Package",
    "column_name": "productId",
    "data_type": "uuid"
  },
  {
    "table_name": "Package",
    "column_name": "lookupKey",
    "data_type": "text"
  },
  {
    "table_name": "Package",
    "column_name": "displayName",
    "data_type": "text"
  },
  {
    "table_name": "Package",
    "column_name": "position",
    "data_type": "integer"
  },
  {
    "table_name": "Package",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Package",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PersonTag",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PersonTag",
    "column_name": "name",
    "data_type": "text"
  },
  {
    "table_name": "PersonTag",
    "column_name": "profileSharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "PersonTag",
    "column_name": "relation",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "PersonTag",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PersonTag",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Product",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Product",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Product",
    "column_name": "storeIdentifier",
    "data_type": "text"
  },
  {
    "table_name": "Product",
    "column_name": "type",
    "data_type": "text"
  },
  {
    "table_name": "Product",
    "column_name": "displayName",
    "data_type": "text"
  },
  {
    "table_name": "Product",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Product",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Profile",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Profile",
    "column_name": "fullName",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "username",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "avatarUrl",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "email",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "passwordHash",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "firstName",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "lastName",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "phone",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "revenuecatAppUserId",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "status",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "addressStreet",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "addressUnit",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "addressCity",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "addressState",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "Profile",
    "column_name": "addressZipcode",
    "data_type": "text"
  },
  {
    "table_name": "Profile",
    "column_name": "isAdmin",
    "data_type": "boolean"
  },
  {
    "table_name": "Profile",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Profile",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileExecutor",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileExecutor",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileExecutor",
    "column_name": "executorId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileExecutor",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileExecutor",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "listenerId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "sharedSince",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "hasAccess",
    "data_type": "boolean"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "lastViewed",
    "data_type": "timestamp without time zone"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "notifications",
    "data_type": "boolean"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileListener",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileRole",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileRole",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileRole",
    "column_name": "role",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "ProfileRole",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileRole",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ProfileSharer",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileSharer",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "ProfileSharer",
    "column_name": "subscriptionStatus",
    "data_type": "boolean"
  },
  {
    "table_name": "ProfileSharer",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Prompt",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Prompt",
    "column_name": "promptText",
    "data_type": "character varying"
  },
  {
    "table_name": "Prompt",
    "column_name": "promptType",
    "data_type": "character varying"
  },
  {
    "table_name": "Prompt",
    "column_name": "isContextEstablishing",
    "data_type": "boolean"
  },
  {
    "table_name": "Prompt",
    "column_name": "airtableId",
    "data_type": "character varying"
  },
  {
    "table_name": "Prompt",
    "column_name": "createdAt",
    "data_type": "timestamp without time zone"
  },
  {
    "table_name": "Prompt",
    "column_name": "updatedAt",
    "data_type": "timestamp without time zone"
  },
  {
    "table_name": "Prompt",
    "column_name": "promptCategoryId",
    "data_type": "uuid"
  },
  {
    "table_name": "Prompt",
    "column_name": "categoryAirtableId",
    "data_type": "character varying"
  },
  {
    "table_name": "Prompt",
    "column_name": "isObjectPrompt",
    "data_type": "boolean"
  },
  {
    "table_name": "Prompt",
    "column_name": "search_vector",
    "data_type": "tsvector"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "category",
    "data_type": "text"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "description",
    "data_type": "text"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "theme",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "airtableId",
    "data_type": "text"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptCategory",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "profileSharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "videoId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "privacyLevel",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "promptId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "search_vector",
    "data_type": "tsvector"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "summary",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponse",
    "column_name": "responseNotes",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "promptResponseId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "profileSharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "fileUrl",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "fileType",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "fileName",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "fileSize",
    "data_type": "integer"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "title",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "description",
    "data_type": "text"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "estimatedYear",
    "data_type": "integer"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "uploadedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "dateCaptured",
    "data_type": "date"
  },
  {
    "table_name": "PromptResponseAttachment",
    "column_name": "yearCaptured",
    "data_type": "integer"
  },
  {
    "table_name": "PromptResponseAttachmentPersonTag",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachmentPersonTag",
    "column_name": "promptResponseAttachmentId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachmentPersonTag",
    "column_name": "personTagId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseAttachmentPersonTag",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponseAttachmentPersonTag",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponseFavorite",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseFavorite",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseFavorite",
    "column_name": "promptResponseId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseFavorite",
    "column_name": "favoritedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "PromptResponseRecentlyWatched",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseRecentlyWatched",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseRecentlyWatched",
    "column_name": "promptResponseId",
    "data_type": "uuid"
  },
  {
    "table_name": "PromptResponseRecentlyWatched",
    "column_name": "watchedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Purchase",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Purchase",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Purchase",
    "column_name": "userId",
    "data_type": "uuid"
  },
  {
    "table_name": "Purchase",
    "column_name": "productId",
    "data_type": "uuid"
  },
  {
    "table_name": "Purchase",
    "column_name": "purchasedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Purchase",
    "column_name": "store",
    "data_type": "text"
  },
  {
    "table_name": "Purchase",
    "column_name": "revenueInUsd",
    "data_type": "numeric"
  },
  {
    "table_name": "Purchase",
    "column_name": "status",
    "data_type": "text"
  },
  {
    "table_name": "Purchase",
    "column_name": "environment",
    "data_type": "text"
  },
  {
    "table_name": "Purchase",
    "column_name": "storePurchaseIdentifier",
    "data_type": "text"
  },
  {
    "table_name": "Purchase",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Purchase",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "userId",
    "data_type": "uuid"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "permissionLevel",
    "data_type": "text"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "ResponsePermission",
    "column_name": "responseId",
    "data_type": "uuid"
  },
  {
    "table_name": "Subscription",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Subscription",
    "column_name": "revenuecatId",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "userId",
    "data_type": "uuid"
  },
  {
    "table_name": "Subscription",
    "column_name": "productId",
    "data_type": "uuid"
  },
  {
    "table_name": "Subscription",
    "column_name": "startsAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Subscription",
    "column_name": "currentPeriodStartsAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Subscription",
    "column_name": "currentPeriodEndsAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Subscription",
    "column_name": "givesAccess",
    "data_type": "boolean"
  },
  {
    "table_name": "Subscription",
    "column_name": "autoRenewalStatus",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "status",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "store",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "environment",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "storeSubscriptionIdentifier",
    "data_type": "text"
  },
  {
    "table_name": "Subscription",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Subscription",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "SubscriptionEntitlement",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "SubscriptionEntitlement",
    "column_name": "subscriptionId",
    "data_type": "uuid"
  },
  {
    "table_name": "SubscriptionEntitlement",
    "column_name": "entitlementId",
    "data_type": "uuid"
  },
  {
    "table_name": "SubscriptionEntitlement",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "SubscriptionEntitlement",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "promptCategoryId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "role",
    "data_type": "text"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicFavorite",
    "column_name": "executorId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "promptCategoryId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "role",
    "data_type": "text"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "sharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicQueueItem",
    "column_name": "executorId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "title",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "description",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "profileSharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "muxPlaybackId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "muxUploadId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "passthrough",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "duration",
    "data_type": "double precision"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "aspectRatio",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "videoQuality",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "maxWidth",
    "data_type": "numeric"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "maxHeight",
    "data_type": "numeric"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "maxFrameRate",
    "data_type": "numeric"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "languageCode",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "resolutionTier",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "url",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "metadata",
    "data_type": "jsonb"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "promptCategoryId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "summary",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "status",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "errorMessage",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideo",
    "column_name": "dateRecorded",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "quality",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "downloadedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "status",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "retries",
    "data_type": "integer"
  },
  {
    "table_name": "TopicVideoDownload",
    "column_name": "last_attempted",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "topicVideoId",
    "data_type": "uuid"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "transcript",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "source",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "type",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "language",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "name",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "muxTrackId",
    "data_type": "text"
  },
  {
    "table_name": "TopicVideoTranscript",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "USState",
    "column_name": "abbreviation",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "USState",
    "column_name": "fullname",
    "data_type": "text"
  },
  {
    "table_name": "USState",
    "column_name": "timezone",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "Video",
    "column_name": "profileSharerId",
    "data_type": "uuid"
  },
  {
    "table_name": "Video",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "muxPlaybackId",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "muxUploadId",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "passthrough",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "duration",
    "data_type": "double precision"
  },
  {
    "table_name": "Video",
    "column_name": "aspectRatio",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "videoQuality",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "maxWidth",
    "data_type": "numeric"
  },
  {
    "table_name": "Video",
    "column_name": "maxHeight",
    "data_type": "numeric"
  },
  {
    "table_name": "Video",
    "column_name": "maxFrameRate",
    "data_type": "numeric"
  },
  {
    "table_name": "Video",
    "column_name": "languageCode",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "resolutionTier",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "airtableRecordId",
    "data_type": "text"
  },
  {
    "table_name": "Video",
    "column_name": "promptId",
    "data_type": "uuid"
  },
  {
    "table_name": "Video",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Video",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "Video",
    "column_name": "status",
    "data_type": "USER-DEFINED"
  },
  {
    "table_name": "Video",
    "column_name": "dateRecorded",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "profileId",
    "data_type": "uuid"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "quality",
    "data_type": "text"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "downloadedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "status",
    "data_type": "text"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "retries",
    "data_type": "integer"
  },
  {
    "table_name": "VideoDownload",
    "column_name": "last_attempted",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "id",
    "data_type": "uuid"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "videoId",
    "data_type": "uuid"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "transcript",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "createdAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "updatedAt",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "source",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "type",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "language",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "name",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "muxTrackId",
    "data_type": "text"
  },
  {
    "table_name": "VideoTranscript",
    "column_name": "muxAssetId",
    "data_type": "text"
  },
  {
    "table_name": "_ListenerPromptViews",
    "column_name": "A",
    "data_type": "uuid"
  },
  {
    "table_name": "_ListenerPromptViews",
    "column_name": "B",
    "data_type": "uuid"
  },
  {
    "table_name": "_ListenerVideoViews",
    "column_name": "A",
    "data_type": "uuid"
  },
  {
    "table_name": "_ListenerVideoViews",
    "column_name": "B",
    "data_type": "uuid"
  },
  {
    "table_name": "_PromptResponseToThematicVideo",
    "column_name": "A",
    "data_type": "uuid"
  },
  {
    "table_name": "_PromptResponseToThematicVideo",
    "column_name": "B",
    "data_type": "uuid"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "id",
    "data_type": "character varying"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "checksum",
    "data_type": "character varying"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "finished_at",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "migration_name",
    "data_type": "character varying"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "logs",
    "data_type": "text"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "rolled_back_at",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "started_at",
    "data_type": "timestamp with time zone"
  },
  {
    "table_name": "_prisma_migrations",
    "column_name": "applied_steps_count",
    "data_type": "integer"
  }
]


[
  {
    "schema_name": "auth",
    "function_name": "email",
    "function_definition": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "jwt",
    "function_definition": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "role",
    "function_definition": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "schema_name": "auth",
    "function_name": "uid",
    "function_definition": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "algorithm_sign",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.algorithm_sign(signables text, secret text, algorithm text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  alg AS (\n    SELECT CASE\n      WHEN algorithm = 'HS256' THEN 'sha256'\n      WHEN algorithm = 'HS384' THEN 'sha384'\n      WHEN algorithm = 'HS512' THEN 'sha512'\n      ELSE '' END AS id)  -- hmac throws error\nSELECT extensions.url_encode(extensions.hmac(signables, secret, alg.id)) FROM alg;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "armor",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "armor",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "crypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "dearmor",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "decrypt_iv",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "digest",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "digest",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "encrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "encrypt_iv",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_random_bytes",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_random_uuid",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_salt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "gen_salt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_cron_access",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_graphql_access",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "grant_pg_net_access",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n  BEGIN\n    IF EXISTS (\n      SELECT 1\n      FROM pg_event_trigger_ddl_commands() AS ev\n      JOIN pg_extension AS ext\n      ON ev.objid = ext.oid\n      WHERE ext.extname = 'pg_net'\n    )\n    THEN\n      IF NOT EXISTS (\n        SELECT 1\n        FROM pg_roles\n        WHERE rolname = 'supabase_functions_admin'\n      )\n      THEN\n        CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n      END IF;\n\n      GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n      IF EXISTS (\n        SELECT FROM pg_extension\n        WHERE extname = 'pg_net'\n        -- all versions in use on existing projects as of 2025-02-20\n        -- version 0.12.0 onwards don't need these applied\n        AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8.0', '0.10.0', '0.11.0')\n      ) THEN\n        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n        ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n        ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n        REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n        REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n        GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n        GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      END IF;\n    END IF;\n  END;\n  $function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hmac",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "hmac",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT blk_read_time double precision, OUT blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_10$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements_info",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pg_stat_statements_reset",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0)\n RETURNS void\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_7$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_armor_headers",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_key_id",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgrst_ddl_watch",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "pgrst_drop_watch",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "set_graphql_placeholder",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "sign",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.sign(payload json, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH\n  header AS (\n    SELECT extensions.url_encode(convert_to('{\"alg\":\"' || algorithm || '\",\"typ\":\"JWT\"}', 'utf8')) AS data\n    ),\n  payload AS (\n    SELECT extensions.url_encode(convert_to(payload::text, 'utf8')) AS data\n    ),\n  signables AS (\n    SELECT header.data || '.' || payload.data AS data FROM header, payload\n    )\nSELECT\n    signables.data || '.' ||\n    extensions.algorithm_sign(signables.data, secret, algorithm) FROM signables;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "try_cast_double",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.try_cast_double(inp text)\n RETURNS double precision\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n  BEGIN\n    BEGIN\n      RETURN inp::double precision;\n    EXCEPTION\n      WHEN OTHERS THEN RETURN NULL;\n    END;\n  END;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "url_decode",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.url_decode(data text)\n RETURNS bytea\n LANGUAGE sql\n IMMUTABLE\nAS $function$\nWITH t AS (SELECT translate(data, '-_', '+/') AS trans),\n     rem AS (SELECT length(t.trans) % 4 AS remainder FROM t) -- compute padding size\n    SELECT decode(\n        t.trans ||\n        CASE WHEN rem.remainder > 0\n           THEN repeat('=', (4 - rem.remainder))\n           ELSE '' END,\n    'base64') FROM t, rem;\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "url_encode",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.url_encode(data bytea)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    SELECT translate(encode(data, 'base64'), E'+/=\\n', '-_');\n$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v1",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v1mc",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v3",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v4",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_generate_v5",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_nil",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_dns",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_oid",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_url",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "uuid_ns_x500",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "schema_name": "extensions",
    "function_name": "verify",
    "function_definition": "CREATE OR REPLACE FUNCTION extensions.verify(token text, secret text, algorithm text DEFAULT 'HS256'::text)\n RETURNS TABLE(header json, payload json, valid boolean)\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  SELECT\n    jwt.header AS header,\n    jwt.payload AS payload,\n    jwt.signature_ok AND tstzrange(\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'nbf')),\n      to_timestamp(extensions.try_cast_double(jwt.payload->>'exp'))\n    ) @> CURRENT_TIMESTAMP AS valid\n  FROM (\n    SELECT\n      convert_from(extensions.url_decode(r[1]), 'utf8')::json AS header,\n      convert_from(extensions.url_decode(r[2]), 'utf8')::json AS payload,\n      r[3] = extensions.algorithm_sign(r[1] || '.' || r[2], secret, algorithm) AS signature_ok\n    FROM regexp_split_to_array(token, '\\.') r\n  ) jwt\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "_internal_resolve",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "comment_directive",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "exception",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "get_schema_version",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "increment_schema_version",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\n  BEGIN\n    perform pg_catalog.nextval('graphql.seq_schema_version');\n  END;\n  $function$\n"
  },
  {
    "schema_name": "graphql",
    "function_name": "resolve",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "schema_name": "graphql_public",
    "function_name": "graphql",
    "function_definition": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "accept_invitation_by_token",
    "function_definition": "CREATE OR REPLACE FUNCTION public.accept_invitation_by_token(p_token text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitation \"Invitation\"%ROWTYPE;\n  v_profile_id uuid;\n  v_now timestamptz;\nBEGIN\n  -- Get current timestamp\n  v_now := now();\n\n  -- Get invitation details\n  SELECT * INTO v_invitation\n  FROM \"Invitation\"\n  WHERE token = p_token\n  AND status = 'PENDING'\n  FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invalid or expired invitation token';\n  END IF;\n\n  -- Get profile ID for the invitee\n  SELECT id INTO v_profile_id\n  FROM \"Profile\"\n  WHERE email = v_invitation.\"inviteeEmail\";\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Profile not found for invitation email';\n  END IF;\n\n  -- Create appropriate relationship based on role\n  IF v_invitation.role = 'EXECUTOR' THEN\n    -- Create executor relationship if it doesn't exist\n    INSERT INTO \"ProfileExecutor\" (\n      \"sharerId\",\n      \"executorId\",\n      \"createdAt\"\n    )\n    VALUES (\n      v_invitation.\"sharerId\",\n      v_profile_id,\n      v_now\n    )\n    ON CONFLICT (\"sharerId\", \"executorId\") DO NOTHING;\n\n    -- Add executor role\n    INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\")\n    VALUES (v_profile_id, 'EXECUTOR', v_now)\n    ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n\n    -- Also create listener relationship for executors\n    INSERT INTO \"ProfileListener\" (\n      \"sharerId\",\n      \"listenerId\",\n      \"sharedSince\",\n      \"hasAccess\",\n      \"createdAt\",\n      \"updatedAt\"\n    )\n    VALUES (\n      v_invitation.\"sharerId\",\n      v_profile_id,\n      v_now,\n      true,\n      v_now,\n      v_now\n    )\n    ON CONFLICT (\"sharerId\", \"listenerId\") DO NOTHING;\n\n    -- Add listener role for executors\n    INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\")\n    VALUES (v_profile_id, 'LISTENER', v_now)\n    ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n  ELSE\n    -- Create listener relationship if it doesn't exist\n    INSERT INTO \"ProfileListener\" (\n      \"sharerId\",\n      \"listenerId\",\n      \"sharedSince\",\n      \"hasAccess\",\n      \"createdAt\",\n      \"updatedAt\"\n    )\n    VALUES (\n      v_invitation.\"sharerId\",\n      v_profile_id,\n      v_now,\n      true,\n      v_now,\n      v_now\n    )\n    ON CONFLICT (\"sharerId\", \"listenerId\") DO NOTHING;\n\n    -- Add listener role\n    INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\")\n    VALUES (v_profile_id, 'LISTENER', v_now)\n    ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n  END IF;\n\n  -- Update invitation status\n  UPDATE \"Invitation\"\n  SET status = 'ACCEPTED',\n      \"acceptedAt\" = v_now,\n      \"updatedAt\" = v_now\n  WHERE id = v_invitation.id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "cancel_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.cancel_invitation(p_invitation_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Update invitation status\n  UPDATE \"Invitation\"\n  SET status = 'CANCELLED',\n      \"updatedAt\" = now()\n  WHERE id = p_invitation_id\n  AND status = 'PENDING'\n  AND \"inviterId\" = auth.uid();\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invalid invitation or not authorized to cancel';\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "check_case_sensitivity",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_case_sensitivity(table_name text, column_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  test_value text := 'TestValue';\n  lowercase_match boolean;\n  uppercase_match boolean;\n  mixed_case_match boolean;\nBEGIN\n  -- Insert a test row\n  EXECUTE format('\n    WITH test_data AS (\n      SELECT %L::text AS test_value\n    )\n    SELECT \n      EXISTS(SELECT 1 FROM %I WHERE %I = %L),\n      EXISTS(SELECT 1 FROM %I WHERE %I = %L),\n      EXISTS(SELECT 1 FROM %I WHERE %I = %L)\n  ', \n    test_value, \n    table_name, column_name, LOWER(test_value),\n    table_name, column_name, UPPER(test_value),\n    table_name, column_name, test_value\n  ) INTO lowercase_match, uppercase_match, mixed_case_match;\n  \n  -- Return result\n  result := json_build_object(\n    'success', true,\n    'table_name', table_name,\n    'column_name', column_name,\n    'test_value', test_value,\n    'lowercase_match', lowercase_match,\n    'uppercase_match', uppercase_match,\n    'mixed_case_match', mixed_case_match,\n    'is_case_sensitive', (NOT lowercase_match OR NOT uppercase_match) AND mixed_case_match\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to check case sensitivity',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "check_column_exists",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_column_exists(table_name text, column_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  column_exists boolean;\nBEGIN\n  -- Check if column exists\n  SELECT EXISTS (\n    SELECT 1\n    FROM information_schema.columns c\n    WHERE c.table_schema = 'public'\n    AND c.table_name = check_column_exists.table_name\n    AND c.column_name = check_column_exists.column_name\n  ) INTO column_exists;\n  \n  -- Return result\n  result := json_build_object(\n    'success', true,\n    'table_name', table_name,\n    'column_name', column_name,\n    'exists', column_exists\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to check column existence',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "check_direct_executor_access",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_direct_executor_access(sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Simple direct check if the current user is an executor for the sharer\n  RETURN EXISTS (\n    SELECT 1 FROM \"ProfileExecutor\" pe\n    WHERE pe.\"sharerId\" = sharer_id AND pe.\"executorId\" = auth.uid()\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "check_direct_sharer_access",
    "function_definition": "CREATE OR REPLACE FUNCTION public.check_direct_sharer_access(sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Simple direct check if the current user is the sharer (by profileId)\n  RETURN EXISTS (\n    SELECT 1 FROM \"ProfileSharer\" ps\n    WHERE ps.id = sharer_id AND ps.\"profileId\" = auth.uid()\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_invitation(p_sharer_id uuid, p_invitee_email text, p_role text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitation_id uuid;\n  v_token text;\nBEGIN\n  -- Generate secure token\n  SELECT generate_invitation_token() INTO v_token;\n\n  -- Create invitation\n  INSERT INTO \"Invitation\" (\n    \"sharerId\",\n    \"inviterId\",\n    \"inviteeEmail\",\n    \"role\",\n    \"status\",\n    \"token\",\n    \"createdAt\"\n  )\n  VALUES (\n    p_sharer_id,\n    auth.uid(),\n    p_invitee_email,\n    p_role,\n    'PENDING',\n    v_token,\n    now()\n  )\n  RETURNING id INTO v_invitation_id;\n\n  RETURN v_invitation_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_listener_for_executor",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_listener_for_executor()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_listener_id UUID;\n  v_now TIMESTAMPTZ := NOW();\nBEGIN\n  -- Check if a ProfileListener relationship already exists\n  SELECT id INTO v_listener_id\n  FROM \"ProfileListener\"\n  WHERE \"listenerId\" = NEW.\"executorId\"\n  AND \"sharerId\" = NEW.\"sharerId\";\n  \n  -- If relationship doesn't exist, create it\n  IF v_listener_id IS NULL THEN\n    -- First try to use the RPC function if it exists\n    BEGIN\n      SELECT create_profile_listener(\n        NEW.\"executorId\",\n        NEW.\"sharerId\",\n        v_now,\n        TRUE\n      ) INTO v_listener_id;\n      \n      RAISE LOG 'Created listener relationship for executor via RPC: %', v_listener_id;\n    EXCEPTION\n      WHEN OTHERS THEN\n        -- If RPC fails, insert directly\n        INSERT INTO \"ProfileListener\" (\n          \"listenerId\",\n          \"sharerId\",\n          \"sharedSince\",\n          \"hasAccess\",\n          \"notifications\",\n          \"createdAt\",\n          \"updatedAt\"\n        )\n        VALUES (\n          NEW.\"executorId\",\n          NEW.\"sharerId\",\n          v_now,\n          TRUE,\n          TRUE,\n          v_now,\n          v_now\n        )\n        RETURNING id INTO v_listener_id;\n        \n        RAISE LOG 'Created listener relationship for executor via direct insert: %', v_listener_id;\n    END;\n  ELSE\n    RAISE LOG 'Listener relationship already exists for executor: %', v_listener_id;\n  END IF;\n  \n  -- Also ensure the user has the LISTENER role\n  PERFORM id FROM \"ProfileRole\" WHERE \"profileId\" = NEW.\"executorId\" AND \"role\" = 'LISTENER';\n  \n  IF NOT FOUND THEN\n    INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\", \"updatedAt\")\n    VALUES (NEW.\"executorId\", 'LISTENER', v_now, v_now);\n    \n    RAISE LOG 'Added LISTENER role for executor: %', NEW.\"executorId\";\n  END IF;\n  \n  -- Also ensure the user has the EXECUTOR role\n  PERFORM id FROM \"ProfileRole\" WHERE \"profileId\" = NEW.\"executorId\" AND \"role\" = 'EXECUTOR';\n  \n  IF NOT FOUND THEN\n    INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\", \"updatedAt\")\n    VALUES (NEW.\"executorId\", 'EXECUTOR', v_now, v_now);\n    \n    RAISE LOG 'Added EXECUTOR role for executor: %', NEW.\"executorId\";\n  END IF;\n  \n  RETURN NEW;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE LOG 'Error in create_listener_for_executor trigger: % (SQLSTATE: %)', SQLERRM, SQLSTATE;\n    RETURN NEW; -- Continue with the insert even if the trigger fails\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_profile_executor",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_profile_executor(p_executor_id uuid, p_sharer_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_id uuid;\n  v_now timestamp with time zone := now();\n  v_existing_id uuid;\nBEGIN\n  -- Check if the relationship already exists\n  SELECT id INTO v_existing_id\n  FROM \"ProfileExecutor\"\n  WHERE \"executorId\" = p_executor_id AND \"sharerId\" = p_sharer_id;\n  \n  -- If relationship exists, return the existing ID\n  IF v_existing_id IS NOT NULL THEN\n    RAISE LOG 'ProfileExecutor relationship already exists with id: %', v_existing_id;\n    RETURN v_existing_id;\n  END IF;\n  \n  -- Create new relationship\n  INSERT INTO \"ProfileExecutor\" (\n    \"executorId\",\n    \"sharerId\",\n    \"createdAt\",\n    \"updatedAt\"\n  )\n  VALUES (\n    p_executor_id,\n    p_sharer_id,\n    v_now,\n    v_now\n  )\n  RETURNING id INTO v_id;\n\n  RAISE LOG 'Created new ProfileExecutor with id: %', v_id;\n  RETURN v_id;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE LOG 'Error in create_profile_executor: % (SQLSTATE: %)', SQLERRM, SQLSTATE;\n    RAISE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_profile_listener",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_profile_listener(p_listener_id uuid, p_sharer_id uuid, p_shared_since timestamp with time zone DEFAULT now(), p_has_access boolean DEFAULT true)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_existing_id UUID;\n  v_new_id UUID;\n  v_now TIMESTAMPTZ := COALESCE(p_shared_since, NOW());\nBEGIN\n  -- Log the function call\n  RAISE LOG 'create_profile_listener() called with listener_id: %, sharer_id: %', \n    p_listener_id, p_sharer_id;\n\n  -- Check if the relationship already exists\n  SELECT id INTO v_existing_id\n  FROM \"ProfileListener\"\n  WHERE \"listenerId\" = p_listener_id AND \"sharerId\" = p_sharer_id;\n\n  -- If it exists, return the existing ID\n  IF v_existing_id IS NOT NULL THEN\n    RAISE LOG 'ProfileListener relationship already exists with id: %', v_existing_id;\n    RETURN v_existing_id;\n  END IF;\n\n  -- Insert the new record\n  INSERT INTO \"ProfileListener\" (\n    \"listenerId\", \n    \"sharerId\", \n    \"sharedSince\", \n    \"hasAccess\", \n    \"createdAt\", \n    \"updatedAt\"\n  )\n  VALUES (\n    p_listener_id, \n    p_sharer_id, \n    v_now, \n    p_has_access, \n    v_now, \n    v_now\n  )\n  RETURNING id INTO v_new_id;\n\n  RAISE LOG 'Created new ProfileListener with id: %', v_new_id;\n  RETURN v_new_id;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE LOG 'Error in create_profile_listener: % (SQLSTATE: %)', SQLERRM, SQLSTATE;\n    RAISE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "create_test_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.create_test_invitation(token_value text, invitee_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  sharer_id uuid;\n  inviter_id uuid;\nBEGIN\n  -- Get a valid sharer ID\n  SELECT id INTO sharer_id FROM \"ProfileSharer\" LIMIT 1;\n  \n  -- Get a valid inviter ID (using the same as sharer for simplicity)\n  inviter_id := sharer_id;\n  \n  -- Check if invitation with this token already exists\n  IF EXISTS (SELECT 1 FROM \"Invitation\" WHERE \"token\" = token_value) THEN\n    -- Return existing invitation\n    SELECT json_build_object(\n      'success', true,\n      'message', 'Invitation with this token already exists',\n      'token', token_value,\n      'exists', true\n    ) INTO result;\n    \n    RETURN result;\n  END IF;\n  \n  -- Insert the invitation with SECURITY DEFINER to bypass RLS\n  INSERT INTO \"Invitation\" (\n    \"token\",\n    \"inviteeEmail\",\n    \"sharerId\",\n    \"inviterId\",\n    \"status\",\n    \"role\",\n    \"createdAt\",\n    \"updatedAt\"\n  ) VALUES (\n    token_value,\n    invitee_email,\n    sharer_id,\n    inviter_id,\n    'PENDING',\n    'LISTENER',\n    NOW(),\n    NOW()\n  );\n  \n  -- Return success\n  result := json_build_object(\n    'success', true,\n    'message', 'Test invitation created successfully',\n    'token', token_value,\n    'sharerId', sharer_id,\n    'inviterId', inviter_id,\n    'exists', false\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to create test invitation',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "exec_sql",
    "function_definition": "CREATE OR REPLACE FUNCTION public.exec_sql(sql text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  EXECUTE sql;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "executor_create_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.executor_create_invitation(executor_id uuid, sharer_id uuid, invitee_email text, role text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitation_id uuid;\nBEGIN\n  -- Verify executor status\n  IF NOT EXISTS (\n    SELECT 1 FROM \"ProfileExecutor\" pe\n    WHERE pe.\"executorId\" = executor_id\n    AND pe.\"sharerId\" = sharer_id\n  ) THEN\n    RAISE EXCEPTION 'Not authorized as executor for this sharer';\n  END IF;\n\n  -- Create invitation\n  INSERT INTO \"Invitation\" (\n    \"sharerId\",\n    \"inviterId\",\n    \"inviteeEmail\",\n    \"role\",\n    \"status\",\n    \"token\",\n    \"createdAt\"\n  )\n  VALUES (\n    sharer_id,\n    executor_id,\n    invitee_email,\n    role,\n    'PENDING',\n    gen_random_uuid()::text,\n    now()\n  )\n  RETURNING id INTO v_invitation_id;\n\n  RETURN v_invitation_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "find_invitation_by_id",
    "function_definition": "CREATE OR REPLACE FUNCTION public.find_invitation_by_id(invitation_id uuid, invitation_token text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  invitation json;\nBEGIN\n  -- Find invitation by ID and token\n  SELECT row_to_json(inv) INTO invitation\n  FROM \"Invitation\" inv\n  WHERE inv.\"id\" = invitation_id\n  AND inv.\"token\" = invitation_token;\n  \n  -- Return result\n  result := json_build_object(\n    'success', true,\n    'id', invitation_id,\n    'token', invitation_token,\n    'invitation', invitation,\n    'found', invitation IS NOT NULL\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to find invitation',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "find_invitation_by_token",
    "function_definition": "CREATE OR REPLACE FUNCTION public.find_invitation_by_token(token_value text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  invitation json;\nBEGIN\n  -- Find invitation by token (exact match)\n  SELECT row_to_json(inv) INTO invitation\n  FROM \"Invitation\" inv\n  WHERE inv.\"token\" = token_value;\n  \n  -- Return result\n  result := json_build_object(\n    'success', true,\n    'token', token_value,\n    'invitation', invitation,\n    'found', invitation IS NOT NULL\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to find invitation',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "find_invitation_by_token_case_insensitive",
    "function_definition": "CREATE OR REPLACE FUNCTION public.find_invitation_by_token_case_insensitive(token_value text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  invitation json;\nBEGIN\n  -- Find invitation by token (case-insensitive)\n  SELECT row_to_json(inv) INTO invitation\n  FROM \"Invitation\" inv\n  WHERE LOWER(inv.\"token\") = LOWER(token_value);\n  \n  -- Return result\n  result := json_build_object(\n    'success', true,\n    'token', token_value,\n    'invitation', invitation,\n    'found', invitation IS NOT NULL\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to find invitation',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "generate_attachment_filename",
    "function_definition": "CREATE OR REPLACE FUNCTION public.generate_attachment_filename(profile_sharer_id uuid, prompt_response_id uuid, original_filename text, attachment_id uuid)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  user_name      text;\n  topic_name     text;\n  file_extension text := '.dat';  -- fallback in case no dot found\n  new_filename   text;\nBEGIN\n  -- Extract extension\n  IF position('.' in original_filename) > 0 THEN\n    file_extension := substr(original_filename, position('.' in original_filename));\n  END IF;\n\n  -- Fetch the user's full name\n  SELECT p.\"fullName\"\n    INTO user_name\n    FROM \"Profile\" p\n    JOIN \"ProfileSharer\" ps ON p.id = ps.\"profileId\"\n   WHERE ps.id = profile_sharer_id;\n\n  IF user_name IS NULL OR user_name = '' THEN\n    user_name := 'Sharer';\n  END IF;\n\n  -- Retrieve topic name from your custom function\n  SELECT get_topic_name(prompt_response_id)\n    INTO topic_name;\n\n  IF topic_name IS NULL OR topic_name = '' THEN\n    topic_name := 'untitled';\n  END IF;\n\n  /* \n    Build final slug: \n    \"lastname-firstname_topic_8charID\" + extension\n    ex: \"smith-jane_vacation_ab12cd34.jpg\"\n  */\n\n  WITH name_parts AS (\n    SELECT\n      COALESCE(NULLIF(split_part(user_name, ' ', 1), ''), 'Unknown') AS first_name,\n      COALESCE(NULLIF(split_part(user_name, ' ', -1), ''), 'User')   AS last_name\n  )\n  SELECT\n    slugify(last_name || '-' || first_name)\n    || '_' || slugify(topic_name)\n    || '_' || substring(attachment_id::text, 1, 8)\n  INTO new_filename\n  FROM name_parts;\n\n  RETURN new_filename || file_extension;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "generate_invitation_token",
    "function_definition": "CREATE OR REPLACE FUNCTION public.generate_invitation_token()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_token text;\nBEGIN\n  -- Generate a secure random token (36 characters)\n  SELECT encode(gen_random_bytes(18), 'hex') INTO v_token;\n  RETURN v_token;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_all_invitations",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_all_invitations()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  invitations json;\nBEGIN\n  -- Get all invitations\n  SELECT json_agg(inv) INTO invitations\n  FROM \"Invitation\" inv;\n  \n  -- Return success\n  result := json_build_object(\n    'success', true,\n    'invitations', COALESCE(invitations, '[]'::json)\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to get invitations',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_attachment_person_tags",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_attachment_person_tags(attachment_ids uuid[])\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  SELECT \n    jsonb_agg(\n      jsonb_build_object(\n        'promptResponseAttachmentId', prapt.\"promptResponseAttachmentId\",\n        'personTagId', prapt.\"personTagId\",\n        'personTag', jsonb_build_object(\n          'id', pt.id,\n          'name', pt.name\n        )\n      )\n    )\n  FROM \"PromptResponseAttachmentPersonTag\" prapt\n  JOIN \"PersonTag\" pt ON pt.id = prapt.\"personTagId\"\n  WHERE prapt.\"promptResponseAttachmentId\" = ANY(attachment_ids)\n  INTO result;\n  \n  RETURN COALESCE(result, '[]'::jsonb);\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_executor_for_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_executor_for_user(user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  SELECT jsonb_build_object(\n    'has_executor_relationship', COUNT(pe.id) > 0,\n    'executor_relationships', COALESCE(\n      jsonb_agg(\n        jsonb_build_object(\n          'id', pe.id,\n          'sharerId', pe.\"sharerId\",\n          'executorId', pe.\"executorId\",\n          'createdAt', pe.\"createdAt\",\n          'sharer', jsonb_build_object(\n            'id', ps.id,\n            'profileId', ps.\"profileId\",\n            'profile', jsonb_build_object(\n              'id', p.id,\n              'firstName', p.\"firstName\",\n              'lastName', p.\"lastName\",\n              'email', p.email,\n              'avatarUrl', p.\"avatarUrl\",\n              'createdAt', p.\"createdAt\"\n            )\n          )\n        )\n      ) FILTER (WHERE pe.id IS NOT NULL), \n      '[]'::jsonb\n    )\n  )\n  INTO result\n  FROM \"ProfileExecutor\" pe\n  JOIN \"ProfileSharer\" ps ON pe.\"sharerId\" = ps.id\n  JOIN \"Profile\" p ON ps.\"profileId\" = p.id\n  WHERE pe.\"executorId\" = user_id;\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_pending_invitations",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_pending_invitations(email_param text, role_type text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  -- Using a direct approach that avoids RLS policies\n  SELECT \n    jsonb_agg(\n      jsonb_build_object(\n        'id', i.id,\n        'token', i.token,\n        'createdAt', i.\"createdAt\",\n        'sharerId', i.\"sharerId\",\n        'inviteeEmail', i.\"inviteeEmail\",\n        'role', i.role,\n        'status', i.status,\n        'sharer', jsonb_build_object(\n          'id', ps.id,\n          'profile', jsonb_build_object(\n            'id', p.id,\n            'firstName', p.\"firstName\",\n            'lastName', p.\"lastName\",\n            'email', p.email,\n            'avatarUrl', p.\"avatarUrl\"\n          )\n        )\n      )\n    )\n  INTO result\n  FROM \"Invitation\" i\n  JOIN \"ProfileSharer\" ps ON i.\"sharerId\" = ps.id\n  JOIN \"Profile\" p ON ps.\"profileId\" = p.id\n  WHERE \n    i.\"inviteeEmail\" = email_param \n    AND i.status = 'PENDING'\n    AND (role_type IS NULL OR i.role::text = role_type);\n\n  -- Return empty array if no results\n  IF result IS NULL THEN\n    RETURN '[]'::jsonb;\n  END IF;\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_person_tags_for_sharer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_person_tags_for_sharer(sharer_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  SELECT \n    jsonb_agg(\n      jsonb_build_object(\n        'id', pt.id,\n        'name', pt.name,\n        'profileSharerId', pt.\"profileSharerId\",\n        'createdAt', pt.\"createdAt\"\n      )\n    )\n  FROM \"PersonTag\" pt\n  WHERE pt.\"profileSharerId\" = sharer_id\n  INTO result;\n  \n  RETURN COALESCE(result, '[]'::jsonb);\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_policies_for_table",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_policies_for_table(table_name text)\n RETURNS TABLE(policyname name, tablename name, schemaname name, roles name[], cmd text, qual text, with_check text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    p.policyname,\n    p.tablename,\n    p.schemaname,\n    p.roles,\n    p.cmd,\n    p.qual,\n    p.with_check\n  FROM\n    pg_policies p\n  WHERE\n    p.tablename = table_name;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_profile_safe",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_profile_safe(target_user_id uuid DEFAULT auth.uid())\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  profile_record jsonb;\nBEGIN\n  -- Get profile data\n  SELECT jsonb_build_object(\n    'id', p.id,\n    'fullName', p.\"fullName\",\n    'displayName', COALESCE(p.\"fullName\", CONCAT(p.\"firstName\", ' ', p.\"lastName\")),\n    'email', p.email,\n    'firstName', p.\"firstName\",\n    'lastName', p.\"lastName\",\n    'avatarUrl', p.\"avatarUrl\",\n    'phone', p.\"phone\",\n    'isAdmin', p.\"isAdmin\",\n    'createdAt', p.\"createdAt\",\n    'updatedAt', p.\"updatedAt\"\n  )\n  INTO profile_record\n  FROM \"Profile\" p\n  WHERE p.id = target_user_id;\n  \n  RETURN profile_record;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_sharer_profile_by_user_id",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_sharer_profile_by_user_id(user_id uuid)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\nBEGIN\n  SELECT jsonb_build_object(\n    'sharerId', ps.id,\n    'profileId', ps.\"profileId\",\n    'exists', true\n  )\n  INTO result\n  FROM \"ProfileSharer\" ps\n  WHERE ps.\"profileId\" = user_id;\n\n  -- Return empty object with exists=false if no sharer profile found\n  IF result IS NULL THEN\n    RETURN jsonb_build_object('exists', false);\n  END IF;\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_sharer_topic_progress",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_sharer_topic_progress(sharer_profile_id uuid, topic_id uuid)\n RETURNS TABLE(total_prompts integer, completed_prompts integer, progress_percent numeric)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    total.count AS total_prompts,\n    completed.count AS completed_prompts,\n    CASE\n      WHEN total.count = 0 THEN 0\n      ELSE (completed.count::DECIMAL / total.count::DECIMAL) * 100\n    END AS progress_percent\n  FROM\n    (SELECT COUNT(*) FROM public.\"Prompt\" p WHERE p.\"promptCategoryId\" = topic_id) AS total,\n    (SELECT COUNT(*) FROM public.\"PromptResponse\" pr\n     JOIN public.\"Prompt\" p ON pr.\"promptId\" = p.\"id\"\n     WHERE pr.\"profileSharerId\" = (\n       SELECT \"id\" FROM public.\"ProfileSharer\" WHERE \"profileId\" = sharer_profile_id\n     )\n       AND p.\"promptCategoryId\" = topic_id\n    ) AS completed;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_table_schema",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_table_schema(table_name text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  columns json;\nBEGIN\n  -- Get table columns\n  SELECT json_agg(\n    json_build_object(\n      'column_name', c.column_name,\n      'data_type', c.data_type,\n      'is_nullable', c.is_nullable,\n      'column_default', c.column_default\n    )\n  ) INTO columns\n  FROM information_schema.columns c\n  WHERE c.table_schema = 'public'\n  AND c.table_name = get_table_schema.table_name;\n  \n  -- Return success\n  result := json_build_object(\n    'success', true,\n    'table_name', table_name,\n    'columns', COALESCE(columns, '[]'::json)\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to get table schema',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_topic_name",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_topic_name(prompt_response_id uuid)\n RETURNS text\n LANGUAGE sql\n STRICT\nAS $function$\n  SELECT pc.category \n  FROM \"PromptResponse\" pr\n  JOIN \"Prompt\" p ON pr.\"promptId\" = p.id\n  JOIN \"PromptCategory\" pc ON p.\"promptCategoryId\" = pc.id\n  WHERE pr.id = prompt_response_id;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "get_user_role_emergency",
    "function_definition": "CREATE OR REPLACE FUNCTION public.get_user_role_emergency(user_id uuid DEFAULT auth.uid())\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  result jsonb;\n  user_roles text[];\n  sharer_record_id uuid;\n  has_sharer boolean;\n  has_executor boolean;\nBEGIN\n  -- Get roles from ProfileRole directly using a direct query\n  SELECT array_agg(role::text) INTO user_roles\n  FROM \"ProfileRole\"\n  WHERE \"profileId\" = user_id;\n  \n  -- Check if user has a sharer profile directly\n  SELECT \n    EXISTS (SELECT 1 FROM \"ProfileSharer\" WHERE \"profileId\" = user_id),\n    (SELECT id FROM \"ProfileSharer\" WHERE \"profileId\" = user_id LIMIT 1)\n  INTO has_sharer, sharer_record_id;\n  \n  -- Check if user has executor relationships directly\n  SELECT EXISTS (SELECT 1 FROM \"ProfileExecutor\" WHERE \"executorId\" = user_id)\n  INTO has_executor;\n  \n  -- Build result object\n  SELECT jsonb_build_object(\n    'roles', COALESCE(user_roles, ARRAY[]::text[]),\n    'sharerId', sharer_record_id,\n    'is_sharer', has_sharer,\n    'has_executor_relationship', has_executor,\n    'timestamp', now()\n  ) INTO result;\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_approved_follow_request",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_approved_follow_request()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.status = 'APPROVED' AND OLD.status != 'APPROVED' THEN\n        INSERT INTO \"ProfileListener\" (\"listenerId\", \"sharerId\")\n        VALUES (NEW.\"requestorId\", NEW.\"sharerId\")\n        ON CONFLICT (\"listenerId\", \"sharerId\") DO NOTHING;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_executor_invitation_notification",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_executor_invitation_notification()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitee_profile_id uuid;\n  v_sharer_profile record;\nBEGIN\n  -- Only proceed if this is an EXECUTOR invitation\n  IF NEW.role != 'EXECUTOR' THEN\n    RETURN NEW;\n  END IF;\n\n  -- Check if invitee already has a profile\n  SELECT id INTO v_invitee_profile_id\n  FROM \"Profile\"\n  WHERE email = LOWER(NEW.\"inviteeEmail\");\n\n  -- If invitee has a profile, create a notification and add EXECUTOR role\n  IF v_invitee_profile_id IS NOT NULL THEN\n    -- Get sharer's profile information\n    SELECT p.* INTO v_sharer_profile\n    FROM \"Profile\" p\n    JOIN \"ProfileSharer\" ps ON ps.\"profileId\" = p.id\n    WHERE ps.id = NEW.\"sharerId\";\n\n    -- Add EXECUTOR role if it doesn't exist\n    INSERT INTO \"ProfileRole\" (\"id\", \"profileId\", \"role\", \"createdAt\", \"updatedAt\")\n    VALUES (\n      gen_random_uuid(),\n      v_invitee_profile_id,\n      'EXECUTOR',\n      NOW(),\n      NOW()\n    )\n    ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n\n    -- Create notification\n    INSERT INTO \"Notification\" (\n      \"id\",\n      \"userId\",\n      \"type\",\n      \"message\",\n      \"data\",\n      \"isRead\",\n      \"createdAt\",\n      \"updatedAt\"\n    ) VALUES (\n      gen_random_uuid(),\n      v_invitee_profile_id,\n      'INVITATION',\n      format(\n        'You have been invited by %s %s to be an executor',\n        v_sharer_profile.\"firstName\",\n        v_sharer_profile.\"lastName\"\n      ),\n      jsonb_build_object(\n        'invitationId', NEW.id,\n        'sharerId', NEW.\"sharerId\",\n        'role', NEW.role,\n        'sharer', jsonb_build_object(\n          'firstName', v_sharer_profile.\"firstName\",\n          'lastName', v_sharer_profile.\"lastName\",\n          'email', v_sharer_profile.email\n        )\n      ),\n      false,\n      NOW(),\n      NOW()\n    );\n  END IF;\n\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_follow_request",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_follow_request(sharer_id uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_request_id uuid;\nBEGIN\n  -- Create follow request\n  INSERT INTO \"FollowRequest\" (\n    \"sharerId\",\n    \"requestorId\",\n    \"status\",\n    \"createdAt\"\n  )\n  VALUES (\n    sharer_id,\n    auth.uid(),\n    'PENDING',\n    now()\n  )\n  RETURNING id INTO v_request_id;\n\n  RETURN v_request_id;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_follow_request_response",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_follow_request_response(request_id uuid, should_approve boolean)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_request \"FollowRequest\"%ROWTYPE;\n  v_now timestamptz;\n  v_listener_id uuid;\nBEGIN\n  -- Get current timestamp\n  v_now := now();\n\n  -- Get request details\n  SELECT * INTO v_request\n  FROM \"FollowRequest\"\n  WHERE id = request_id\n  AND status = 'PENDING'\n  FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invalid or already processed follow request';\n  END IF;\n\n  -- Verify the current user is the sharer\n  IF NOT EXISTS (\n    SELECT 1 FROM \"ProfileSharer\" ps\n    WHERE ps.id = v_request.\"sharerId\"\n    AND ps.\"profileId\" = auth.uid()\n  ) THEN\n    RAISE EXCEPTION 'Not authorized to handle this follow request';\n  END IF;\n\n  IF should_approve THEN\n    -- Generate UUID for ProfileListener\n    v_listener_id := gen_random_uuid();\n\n    -- Create listener relationship\n    INSERT INTO \"ProfileListener\" (\n      \"id\",\n      \"sharerId\",\n      \"listenerId\",\n      \"sharedSince\",\n      \"hasAccess\",\n      \"createdAt\",\n      \"updatedAt\"\n    )\n    VALUES (\n      v_listener_id,\n      v_request.\"sharerId\",\n      v_request.\"requestorId\",\n      v_now,\n      true,\n      v_now,\n      v_now\n    );\n\n    -- Add listener role if not exists\n    INSERT INTO \"ProfileRole\" (\"id\", \"profileId\", \"role\", \"createdAt\", \"updatedAt\")\n    VALUES (\n      gen_random_uuid(),\n      v_request.\"requestorId\",\n      'LISTENER',\n      v_now,\n      v_now\n    )\n    ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n\n    -- Update request status\n    UPDATE \"FollowRequest\"\n    SET status = 'APPROVED',\n        \"approvedAt\" = v_now,\n        \"updatedAt\" = v_now\n    WHERE id = request_id;\n  ELSE\n    -- Update request status\n    UPDATE \"FollowRequest\"\n    SET status = 'DENIED',\n        \"deniedAt\" = v_now,\n        \"updatedAt\" = v_now\n    WHERE id = request_id;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_invitation_acceptance",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_invitation_acceptance(invitation_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitation \"Invitation\"%ROWTYPE;\nBEGIN\n  -- Get invitation details\n  SELECT * INTO v_invitation\n  FROM \"Invitation\"\n  WHERE id = invitation_id\n  AND status = 'PENDING'\n  FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invalid or already processed invitation';\n  END IF;\n\n  -- Update invitation status\n  UPDATE \"Invitation\"\n  SET status = 'ACCEPTED',\n      \"acceptedAt\" = now()\n  WHERE id = invitation_id;\n\n  -- Create appropriate relationship based on role\n  IF v_invitation.role = 'EXECUTOR' THEN\n    INSERT INTO \"ProfileExecutor\" (\"sharerId\", \"executorId\", \"createdAt\")\n    VALUES (v_invitation.\"sharerId\", auth.uid(), now());\n  ELSIF v_invitation.role = 'LISTENER' THEN\n    INSERT INTO \"ProfileListener\" (\"sharerId\", \"listenerId\", \"sharedSince\", \"hasAccess\", \"createdAt\")\n    VALUES (v_invitation.\"sharerId\", auth.uid(), now(), true, now());\n  END IF;\n\n  -- Add role if not exists\n  INSERT INTO \"ProfileRole\" (\"profileId\", \"role\", \"createdAt\")\n  VALUES (auth.uid(), v_invitation.role, now())\n  ON CONFLICT (\"profileId\", \"role\") DO NOTHING;\n\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_new_user",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  v_now timestamptz;\n  v_profile_id uuid;\nBEGIN\n  v_now := now();\n  v_profile_id := new.id;\n\n  -- Insert a record into the Profile table.\n  INSERT INTO public.\"Profile\" (\n      \"id\",\n      \"email\",\n      \"firstName\",\n      \"lastName\",\n      \"phone\",\n      \"createdAt\",\n      \"updatedAt\"\n  )\n  VALUES (\n      v_profile_id,\n      new.email,\n      COALESCE(new.raw_user_meta_data->>'firstName', ''),\n      COALESCE(new.raw_user_meta_data->>'lastName', ''),\n      COALESCE(new.raw_user_meta_data->>'phone', ''),\n      v_now,\n      v_now\n  );\n\n  -- Insert a corresponding role record (as a LISTENER)\n  INSERT INTO public.\"ProfileRole\" (\n      \"id\",\n      \"profileId\",\n      \"role\"\n  )\n  VALUES (\n      gen_random_uuid(),  -- requires pgcrypto; ensure it’s enabled\n      v_profile_id,\n      'LISTENER'\n  );\n\n  RETURN new;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE EXCEPTION 'Failed to create user profile: % (SQLSTATE: %)', SQLERRM, SQLSTATE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "handle_profile_updated",
    "function_definition": "CREATE OR REPLACE FUNCTION public.handle_profile_updated()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.\"updatedAt\" = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_role",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_role(user_id uuid, role_name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1\n    FROM \"ProfileRole\"\n    WHERE \"profileId\" = user_id\n    AND role = role_name\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_sharer_access",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_sharer_access(sharer_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT \n    public.is_admin() OR \n    public.is_sharer_owner(sharer_id) OR \n    public.is_executor_for_sharer(sharer_id);\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "has_sharer_access_check",
    "function_definition": "CREATE OR REPLACE FUNCTION public.has_sharer_access_check(user_id uuid, sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  is_admin boolean;\n  is_owner boolean;\n  is_executor boolean;\nBEGIN\n  -- Check if user is admin\n  SELECT is_admin(user_id) INTO is_admin;\n  \n  IF is_admin THEN\n    RETURN true;\n  END IF;\n  \n  -- Check if user is the owner of the sharer profile\n  SELECT EXISTS (\n    SELECT 1 FROM \"ProfileSharer\" ps\n    WHERE ps.id = sharer_id AND ps.\"profileId\" = user_id\n  ) INTO is_owner;\n  \n  IF is_owner THEN\n    RETURN true;\n  END IF;\n  \n  -- Check if user is an executor for this sharer\n  SELECT EXISTS (\n    SELECT 1 FROM \"ProfileExecutor\" pe\n    WHERE pe.\"sharerId\" = sharer_id AND pe.\"executorId\" = user_id\n  ) INTO is_executor;\n  \n  RETURN is_executor;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "insert_test_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.insert_test_invitation(token_value text, invitee_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  sharer_id uuid;\n  inviter_id uuid;\nBEGIN\n  -- Get a valid sharer ID\n  SELECT id INTO sharer_id FROM \"ProfileSharer\" LIMIT 1;\n  \n  -- Get a valid inviter ID (using the same as sharer for simplicity)\n  inviter_id := sharer_id;\n  \n  -- Insert the invitation with SECURITY DEFINER to bypass RLS\n  INSERT INTO \"Invitation\" (\n    \"token\",\n    \"inviteeEmail\",\n    \"sharerId\",\n    \"inviterId\",\n    \"status\",\n    \"role\",\n    \"createdAt\",\n    \"updatedAt\"\n  ) VALUES (\n    token_value,\n    invitee_email,\n    sharer_id,\n    inviter_id,\n    'PENDING',\n    'LISTENER',\n    NOW(),\n    NOW()\n  );\n  \n  -- Return success\n  result := json_build_object(\n    'success', true,\n    'message', 'Test invitation created successfully',\n    'token', token_value,\n    'sharerId', sharer_id,\n    'inviterId', inviter_id\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to create test invitation',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_active_executor_for",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_active_executor_for(executor_id uuid, profile_sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 \n    FROM \"ProfileExecutor\" pe\n    JOIN \"ProfileSharer\" ps ON ps.id = pe.\"sharerId\"\n    WHERE pe.\"executorId\" = executor_id\n    AND ps.\"profileId\" = profile_sharer_id\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin(user_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n  is_admin boolean;\nBEGIN\n  -- Check if the user is an admin via metadata or has ADMIN role\n  SELECT EXISTS (\n    SELECT 1 FROM auth.users \n    WHERE id = user_id \n    AND ((raw_app_meta_data->>'role')::text = 'admin' \n         OR COALESCE((raw_app_meta_data->>'is_super_admin')::boolean, false) = true)\n  ) OR EXISTS (\n    SELECT 1 FROM \"ProfileRole\" WHERE \"profileId\" = user_id AND role = 'ADMIN'\n  ) INTO is_admin;\n  \n  RETURN is_admin;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_admin",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin()\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT EXISTS (\n    SELECT 1 FROM auth.users \n    WHERE id = auth.uid() \n    AND ((raw_app_meta_data->>'role')::text = 'admin' \n         OR COALESCE((raw_app_meta_data->>'is_super_admin')::boolean, false) = true)\n  );\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_admin_simple",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_admin_simple()\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM auth.users \n    WHERE id = auth.uid() \n    AND ((raw_app_meta_data->>'role')::text = 'admin' \n         OR COALESCE((raw_app_meta_data->>'is_super_admin')::boolean, false) = true)\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_executor_for",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_executor_for(executor_id uuid, sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1\n    FROM \"ProfileExecutor\"\n    WHERE \"executorId\" = executor_id\n    AND \"sharerId\" = sharer_id\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_executor_for_sharer",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_executor_for_sharer(sharer_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT EXISTS (\n    SELECT 1 FROM \"ProfileExecutor\" pe\n    WHERE pe.\"sharerId\" = sharer_id AND pe.\"executorId\" = auth.uid()\n  );\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_listener_for",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_listener_for(listener_id uuid, sharer_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN EXISTS (\n    SELECT 1\n    FROM \"ProfileListener\"\n    WHERE \"listenerId\" = listener_id\n    AND \"sharerId\" = sharer_id\n    AND \"hasAccess\" = true\n  );\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "is_sharer_owner",
    "function_definition": "CREATE OR REPLACE FUNCTION public.is_sharer_owner(sharer_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  SELECT EXISTS (\n    SELECT 1 FROM \"ProfileSharer\" ps\n    WHERE ps.id = sharer_id AND ps.\"profileId\" = auth.uid()\n  );\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "list_tables",
    "function_definition": "CREATE OR REPLACE FUNCTION public.list_tables()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  result json;\n  tables json;\nBEGIN\n  -- Get all tables in the public schema\n  SELECT json_agg(\n    json_build_object(\n      'tablename', t.tablename,\n      'tableowner', t.tableowner,\n      'hasindexes', t.hasindexes,\n      'hasrules', t.hasrules,\n      'hastriggers', t.hastriggers\n    )\n  ) INTO tables\n  FROM pg_catalog.pg_tables t\n  WHERE t.schemaname = 'public';\n  \n  -- Return success\n  result := json_build_object(\n    'success', true,\n    'tables', COALESCE(tables, '[]'::json)\n  );\n  \n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  -- Return error\n  result := json_build_object(\n    'success', false,\n    'message', 'Failed to list tables',\n    'error', SQLERRM,\n    'errorCode', SQLSTATE\n  );\n  \n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "prompt_response_search_update",
    "function_definition": "CREATE OR REPLACE FUNCTION public.prompt_response_search_update()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.search_vector := to_tsvector('pg_catalog.english', COALESCE(NEW.\"responseNotes\", ''));\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "resend_invitation",
    "function_definition": "CREATE OR REPLACE FUNCTION public.resend_invitation(p_invitation_id uuid)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_invitation \"Invitation\"%ROWTYPE;\n  v_new_token text;\nBEGIN\n  -- Get invitation details\n  SELECT * INTO v_invitation\n  FROM \"Invitation\"\n  WHERE id = p_invitation_id\n  AND status = 'PENDING'\n  FOR UPDATE;\n\n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Invalid or already processed invitation';\n  END IF;\n\n  -- Verify the current user is the inviter\n  IF v_invitation.\"inviterId\" != auth.uid() THEN\n    RAISE EXCEPTION 'Not authorized to resend this invitation';\n  END IF;\n\n  -- Generate new token\n  SELECT generate_invitation_token() INTO v_new_token;\n\n  -- Update invitation with new token\n  UPDATE \"Invitation\"\n  SET token = v_new_token,\n      \"updatedAt\" = now()\n  WHERE id = p_invitation_id;\n\n  RETURN v_new_token;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "revoke_executor_access",
    "function_definition": "CREATE OR REPLACE FUNCTION public.revoke_executor_access(executor_id uuid, sharer_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Delete executor relationship\n  DELETE FROM \"ProfileExecutor\"\n  WHERE \"executorId\" = executor_id\n  AND \"sharerId\" = sharer_id;\n\n  -- Remove executor role if no other relationships exist\n  IF NOT EXISTS (\n    SELECT 1\n    FROM \"ProfileExecutor\"\n    WHERE \"executorId\" = executor_id\n  ) THEN\n    DELETE FROM \"ProfileRole\"\n    WHERE \"profileId\" = executor_id\n    AND role = 'EXECUTOR';\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "revoke_listener_access",
    "function_definition": "CREATE OR REPLACE FUNCTION public.revoke_listener_access(listener_id uuid, sharer_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Update listener relationship to remove access\n  UPDATE \"ProfileListener\"\n  SET \"hasAccess\" = false,\n      \"updatedAt\" = now()\n  WHERE \"listenerId\" = listener_id\n  AND \"sharerId\" = sharer_id;\n\n  -- Remove listener role if no other relationships exist with access\n  IF NOT EXISTS (\n    SELECT 1\n    FROM \"ProfileListener\"\n    WHERE \"listenerId\" = listener_id\n    AND \"hasAccess\" = true\n  ) THEN\n    DELETE FROM \"ProfileRole\"\n    WHERE \"profileId\" = listener_id\n    AND role = 'LISTENER';\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "set_video_date_recorded",
    "function_definition": "CREATE OR REPLACE FUNCTION public.set_video_date_recorded()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF NEW.\"dateRecorded\" IS NULL THEN\n    NEW.\"dateRecorded\" := NEW.\"createdAt\";\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "slugify",
    "function_definition": "CREATE OR REPLACE FUNCTION public.slugify(text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n  SELECT lower(regexp_replace(regexp_replace($1, '[^a-zA-Z0-9\\s-]', ''), '\\s+', '-', 'g'));\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_auth_admin_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_auth_admin_status()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Check if isAdmin has changed\n  IF NEW.\"isAdmin\" IS DISTINCT FROM OLD.\"isAdmin\" THEN\n    UPDATE auth.users\n    SET \n      -- Update the raw_app_meta_data \"role\" key:\n      raw_app_meta_data = jsonb_set(\n        COALESCE(raw_app_meta_data, '{}'::jsonb),\n        '{role}',\n        to_jsonb(CASE WHEN NEW.\"isAdmin\" THEN 'admin' ELSE 'authenticated' END),\n        true\n      ),\n      -- Optionally, update the is_super_admin column:\n      is_super_admin = NEW.\"isAdmin\",\n      updated_at = now()\n    WHERE id = NEW.id;  -- Assuming NEW.id is the auth user's id.\n  END IF;\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_follow_request_status_timestamps",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_follow_request_status_timestamps()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.status = 'APPROVED' AND OLD.status != 'APPROVED' THEN\n        NEW.\"approvedAt\" = now();\n        NEW.\"deniedAt\" = NULL;\n    ELSIF NEW.status = 'DENIED' AND OLD.status != 'DENIED' THEN\n        NEW.\"deniedAt\" = now();\n        NEW.\"approvedAt\" = NULL;\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_follow_request_updated_at",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_follow_request_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.\"updatedAt\" = now();\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_full_name",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_full_name()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  -- Concatenate firstName and lastName (with a space)\n  NEW.\"fullName\" := NEW.\"firstName\" || ' ' || NEW.\"lastName\";\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_invitation_status",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_invitation_status(p_invitation_id uuid, p_status text, p_accepted_at timestamp with time zone DEFAULT NULL::timestamp with time zone)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_id UUID;\n  v_now TIMESTAMPTZ := COALESCE(p_accepted_at, NOW());\nBEGIN\n  -- Log the function call\n  RAISE LOG 'update_invitation_status() called with invitation_id: %, status: %', \n    p_invitation_id, p_status;\n\n  -- Update the invitation status\n  UPDATE \"Invitation\"\n  SET \n    \"status\" = p_status::\"InvitationStatus\",\n    \"acceptedAt\" = CASE WHEN p_status = 'ACCEPTED' THEN v_now ELSE \"acceptedAt\" END,\n    \"updatedAt\" = v_now\n  WHERE \"id\" = p_invitation_id\n  RETURNING \"id\" INTO v_id;\n\n  -- If no rows were updated, the invitation doesn't exist\n  IF v_id IS NULL THEN\n    RAISE EXCEPTION 'Invitation with ID % not found', p_invitation_id;\n  END IF;\n\n  RAISE LOG 'Updated invitation status to % for invitation with id: %', p_status, v_id;\n  RETURN v_id;\nEXCEPTION\n  WHEN OTHERS THEN\n    RAISE LOG 'Error in update_invitation_status: % (SQLSTATE: %)', SQLERRM, SQLSTATE;\n    RAISE;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_prompt_search_vector",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_prompt_search_vector()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.\"search_vector\" := to_tsvector('english', coalesce(NEW.\"promptText\", ''));\n    RETURN NEW;\nEND; $function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_topicvideotranscript_updated_at",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_topicvideotranscript_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.\"updatedAt\" = now();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "public",
    "function_name": "update_updatedat_column",
    "function_definition": "CREATE OR REPLACE FUNCTION public.update_updatedat_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.\"updatedAt\" = now();\n  RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "apply_rls",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "broadcast_changes",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "build_prepared_statement_sql",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "cast",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "check_equality_op",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "is_visible_through_filters",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "list_changes",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "quote_wal2json",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "send",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      PERFORM pg_notify(\n          'realtime:system',\n          jsonb_build_object(\n              'error', SQLERRM,\n              'function', 'realtime.send',\n              'event', event,\n              'topic', topic,\n              'private', private\n          )::text\n      );\n  END;\nEND;\n$function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "subscription_check_filters",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "to_regrole",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "schema_name": "realtime",
    "function_name": "topic",
    "function_definition": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "can_insert_object",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "extension",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\n_filename text;\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\tselect _parts[array_length(_parts,1)] into _filename;\n\t-- @todo return the last part instead of 2\n\treturn reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "filename",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "foldername",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[1:array_length(_parts,1)-1];\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "get_size_by_bucket",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::int) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "list_multipart_uploads_with_delimiter",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "list_objects_with_delimiter",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "operation",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "search",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n  v_order_by text;\n  v_sort_order text;\nbegin\n  case\n    when sortcolumn = 'name' then\n      v_order_by = 'name';\n    when sortcolumn = 'updated_at' then\n      v_order_by = 'updated_at';\n    when sortcolumn = 'created_at' then\n      v_order_by = 'created_at';\n    when sortcolumn = 'last_accessed_at' then\n      v_order_by = 'last_accessed_at';\n    else\n      v_order_by = 'name';\n  end case;\n\n  case\n    when sortorder = 'asc' then\n      v_sort_order = 'asc';\n    when sortorder = 'desc' then\n      v_sort_order = 'desc';\n    else\n      v_sort_order = 'asc';\n  end case;\n\n  v_order_by = v_order_by || ' ' || v_sort_order;\n\n  return query execute\n    'with folders as (\n       select path_tokens[$1] as folder\n       from storage.objects\n         where objects.name ilike $2 || $3 || ''%''\n           and bucket_id = $4\n           and array_length(objects.path_tokens, 1) <> $1\n       group by folder\n       order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema_name": "storage",
    "function_name": "update_updated_at_column",
    "function_definition": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "create_secret",
    "function_definition": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE sql\nAS $function$\n    INSERT INTO vault.secrets (secret, name, description, key_id)\n    VALUES (\n        new_secret,\n        new_name,\n        new_description,\n        CASE WHEN new_key_id IS NULL THEN (pgsodium.create_key()).id ELSE new_key_id END)\n    RETURNING id;\n    $function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "secrets_encrypt_secret_secret",
    "function_definition": "CREATE OR REPLACE FUNCTION vault.secrets_encrypt_secret_secret()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n\t\tBEGIN\n\t\t        new.secret = CASE WHEN new.secret IS NULL THEN NULL ELSE\n\t\t\tCASE WHEN new.key_id IS NULL THEN NULL ELSE pg_catalog.encode(\n\t\t\t  pgsodium.crypto_aead_det_encrypt(\n\t\t\t\tpg_catalog.convert_to(new.secret, 'utf8'),\n\t\t\t\tpg_catalog.convert_to((new.id::text || new.description::text || new.created_at::text || new.updated_at::text)::text, 'utf8'),\n\t\t\t\tnew.key_id::uuid,\n\t\t\t\tnew.nonce\n\t\t\t  ),\n\t\t\t\t'base64') END END;\n\t\tRETURN new;\n\t\tEND;\n\t\t$function$\n"
  },
  {
    "schema_name": "vault",
    "function_name": "update_secret",
    "function_definition": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE sql\nAS $function$\n\tUPDATE vault.decrypted_secrets s\n    SET\n        secret = CASE WHEN new_secret IS NULL THEN s.decrypted_secret ELSE new_secret END,\n        name = CASE WHEN new_name IS NULL THEN s.name ELSE new_name END,\n        description = CASE WHEN new_description IS NULL THEN s.description ELSE new_description END,\n        key_id = CASE WHEN new_key_id IS NULL THEN s.key_id ELSE new_key_id END,\n        updated_at = CURRENT_TIMESTAMP\n    WHERE s.id = secret_id\n    $function$\n"
  }
]


[
  {
    "schema_name": "public",
    "table_name": "Entitlement",
    "policy_name": "Allow SELECT on entitlements to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "Delete follow requests",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = \"requestorId\") OR (auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\"))) OR (auth.uid() IN ( SELECT \"ProfileExecutor\".\"executorId\"\n   FROM \"ProfileExecutor\"\n  WHERE (\"ProfileExecutor\".\"sharerId\" = \"FollowRequest\".\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "Executors can manage follow requests",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (pe.\"sharerId\" = \"FollowRequest\".\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "FollowRequest_delete_policy",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "has_sharer_access(\"sharerId\")",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "Update follow requests",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\"))) OR (auth.uid() IN ( SELECT \"ProfileExecutor\".\"executorId\"\n   FROM \"ProfileExecutor\"\n  WHERE (\"ProfileExecutor\".\"sharerId\" = \"FollowRequest\".\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "View follow requests",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = \"requestorId\") OR ((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\"))) OR (auth.uid() IN ( SELECT \"ProfileExecutor\".\"executorId\"\n   FROM \"ProfileExecutor\"\n  WHERE (\"ProfileExecutor\".\"sharerId\" = \"FollowRequest\".\"sharerId\")))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "create_follow_requests",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "((auth.uid() = \"requestorId\") AND (EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "update_follow_requests",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "FollowRequest",
    "policy_name": "view_follow_requests",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid() = \"requestorId\") OR (EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"FollowRequest\".\"sharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid())))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Allow inserting invitations without profile",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Allow selecting own invitations",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Invitation\".\"sharerId\")))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Enable all for authenticated users",
    "command_type": "ALL",
    "policy_roles": "{authenticated}",
    "using_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Invitation\".\"sharerId\")))",
    "with_check_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Invitation\".\"sharerId\")))"
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Executors can manage invitations",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (pe.\"sharerId\" = \"Invitation\".\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Invitees can access invitations sent to them",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(\"inviteeEmail\" = ( SELECT \"Profile\".email\n   FROM \"Profile\"\n  WHERE (\"Profile\".id = auth.uid())))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Inviters can access invitations they sent",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"inviterId\" = auth.uid())",
    "with_check_expression": "(\"inviterId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Users can create invitations",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((auth.uid() = \"inviterId\") AND (EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".\"profileId\" = auth.uid()) AND (\"ProfileSharer\".id = \"Invitation\".\"sharerId\")))) AND (role = ANY (ARRAY['LISTENER'::\"Role\", 'EXECUTOR'::\"Role\"])))"
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Users can update own invitations",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = \"inviterId\") OR (auth.uid() IN ( SELECT \"Profile\".id\n   FROM \"Profile\"\n  WHERE (\"Profile\".email = \"Invitation\".\"inviteeEmail\"))))",
    "with_check_expression": "((auth.uid() = \"inviterId\") OR (auth.uid() IN ( SELECT \"Profile\".id\n   FROM \"Profile\"\n  WHERE (\"Profile\".email = \"Invitation\".\"inviteeEmail\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Users can view invitations",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = \"inviterId\") OR (auth.uid() IN ( SELECT \"Profile\".id\n   FROM \"Profile\"\n  WHERE (\"Profile\".email = \"Invitation\".\"inviteeEmail\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Invitation",
    "policy_name": "Users can view own invitations",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = \"inviterId\") OR (auth.uid() IN ( SELECT \"Profile\".id\n   FROM \"Profile\"\n  WHERE (\"Profile\".email = \"Invitation\".\"inviteeEmail\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Notification",
    "policy_name": "Notification_executor_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((pe.\"sharerId\" = ps.id)))\n  WHERE ((ps.\"profileId\" = \"Notification\".\"userId\") AND (pe.\"executorId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Notification",
    "policy_name": "Notification_owner_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"userId\" = auth.uid())",
    "with_check_expression": "(\"userId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "Notification",
    "policy_name": "Notification_service_role_policy",
    "command_type": "INSERT",
    "policy_roles": "{service_role}",
    "using_expression": null,
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "Object",
    "policy_name": "Listeners can view objects from accessible prompt responses",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"PromptResponse\" pr\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (pr.\"privacyLevel\" = 'Public'::text) AND (EXISTS ( SELECT 1\n           FROM \"ProfileListener\" pl\n          WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = pr.\"profileSharerId\") AND (pl.\"hasAccess\" = true)))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Object",
    "policy_name": "Sharers can access their own objects",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((\"userId\" = auth.uid()) OR ((\"promptResponseId\" IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (ps.\"profileId\" = auth.uid()))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Object",
    "policy_name": "Sharers can delete their own objects",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((\"userId\" = auth.uid()) OR ((\"promptResponseId\" IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (ps.\"profileId\" = auth.uid()))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Object",
    "policy_name": "Sharers can insert objects",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((EXISTS ( SELECT 1\n   FROM \"ProfileRole\"\n  WHERE ((\"ProfileRole\".\"profileId\" = auth.uid()) AND (\"ProfileRole\".role = 'SHARER'::\"Role\")))) AND ((\"userId\" = auth.uid()) OR ((\"promptResponseId\" IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (ps.\"profileId\" = auth.uid())))))))"
  },
  {
    "schema_name": "public",
    "table_name": "Object",
    "policy_name": "Sharers can update their own objects",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((\"userId\" = auth.uid()) OR ((\"promptResponseId\" IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (ps.\"profileId\" = auth.uid()))))))",
    "with_check_expression": "((\"userId\" = auth.uid()) OR ((\"promptResponseId\" IS NOT NULL) AND (EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"Object\".\"promptResponseId\") AND (ps.\"profileId\" = auth.uid()))))))"
  },
  {
    "schema_name": "public",
    "table_name": "ObjectCategory",
    "policy_name": "Allow SELECT on object categories to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Offering",
    "policy_name": "Allow SELECT on offerings to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Package",
    "policy_name": "Allow SELECT on packages to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "Executors can manage person tags",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"PersonTag\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "PersonTag_admin_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "is_admin()",
    "with_check_expression": "is_admin()"
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "PersonTag_executor_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"sharerId\" = \"PersonTag\".\"profileSharerId\") AND (pe.\"executorId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"sharerId\" = \"PersonTag\".\"profileSharerId\") AND (pe.\"executorId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "PersonTag_sharer_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"PersonTag\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"PersonTag\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "person_tag_delete",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"PersonTag\".\"profileSharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "person_tag_insert",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"PersonTag\".\"profileSharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "person_tag_select",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"PersonTag\".\"profileSharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PersonTag",
    "policy_name": "person_tag_update",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"PersonTag\".\"profileSharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"PersonTag\".\"profileSharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "Product",
    "policy_name": "Allow SELECT on products to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Admins can do anything",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(auth.role() = 'ADMIN'::text)",
    "with_check_expression": "(auth.role() = 'ADMIN'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Allow individual users to SELECT their own profile",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(id = auth.uid())",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Allow individual users to UPDATE their own profile",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(id = auth.uid())",
    "with_check_expression": "(id = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Executors can access sharer profiles",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((pe.\"sharerId\" = ps.id)))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"Profile\".id))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Executors can see all listeners and executors for their Sharer",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((id = auth.uid()) OR (EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" meexec\n     JOIN \"ProfileExecutor\" otherexec ON ((meexec.\"sharerId\" = otherexec.\"sharerId\")))\n  WHERE ((meexec.\"executorId\" = auth.uid()) AND (otherexec.\"executorId\" = \"Profile\".id)))) OR (EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" meexec\n     JOIN \"ProfileListener\" pl ON ((meexec.\"sharerId\" = pl.\"sharerId\")))\n  WHERE ((meexec.\"executorId\" = auth.uid()) AND (pl.\"listenerId\" = \"Profile\".id)))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Executors can view profiles of users connected to their sharer",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (EXISTS ( SELECT 1\n           FROM ( SELECT pl.\"listenerId\" AS user_id\n                   FROM \"ProfileListener\" pl\n                  WHERE (pl.\"sharerId\" IN ( SELECT pe2.\"sharerId\"\n                           FROM \"ProfileExecutor\" pe2\n                          WHERE (pe2.\"executorId\" = auth.uid())))\n                UNION\n                 SELECT pe3.\"executorId\" AS user_id\n                   FROM \"ProfileExecutor\" pe3\n                  WHERE (pe3.\"sharerId\" IN ( SELECT pe4.\"sharerId\"\n                           FROM \"ProfileExecutor\" pe4\n                          WHERE (pe4.\"executorId\" = auth.uid())))) connected_users\n          WHERE (connected_users.user_id = pe.id))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Profile_select_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR ((id = auth.uid()) OR (EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((pe.\"sharerId\" = ps.id)))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"Profile\".id))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Profile_update_policy",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (id = auth.uid()))",
    "with_check_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (id = auth.uid()))"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can insert own profile",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(auth.uid() = id)"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can update own profile",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() = id)",
    "with_check_expression": "(auth.uid() = id)"
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can view own profile",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(auth.uid() = id)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can view profiles",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((id = auth.uid()) OR (EXISTS ( SELECT 1\n   FROM \"ProfileRole\" pr\n  WHERE ((pr.\"profileId\" = \"Profile\".id) AND (pr.role = 'SHARER'::\"Role\")))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can view sharer profiles",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((EXISTS ( SELECT 1\n   FROM \"ProfileRole\" pr\n  WHERE ((pr.\"profileId\" = \"Profile\".id) AND (pr.role = 'SHARER'::\"Role\")))) AND ((id <> auth.uid()) AND ((EXISTS ( SELECT 1\n   FROM (\"FollowRequest\" fr\n     JOIN \"ProfileSharer\" ps ON ((ps.\"profileId\" = \"Profile\".id)))\n  WHERE ((fr.\"requestorId\" = auth.uid()) AND (fr.\"sharerId\" = ps.id) AND (fr.status = 'PENDING'::follow_request_status)))) OR (EXISTS ( SELECT 1\n   FROM (\"ProfileListener\" pl\n     JOIN \"ProfileSharer\" ps ON ((ps.\"profileId\" = \"Profile\".id)))\n  WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = ps.id) AND (pl.\"hasAccess\" = true)))) OR (EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.\"profileId\" = \"Profile\".id)))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (pe.\"sharerId\" = ps.id)))) OR (NOT (EXISTS ( SELECT 1\n   FROM (\"FollowRequest\" fr\n     JOIN \"ProfileSharer\" ps ON ((ps.\"profileId\" = \"Profile\".id)))\n  WHERE ((fr.\"requestorId\" = auth.uid()) AND (fr.\"sharerId\" = ps.id))))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "Users can view their own profile and SHARER profiles",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() = id) OR (EXISTS ( SELECT 1\n   FROM \"ProfileRole\"\n  WHERE ((\"ProfileRole\".\"profileId\" = \"Profile\".id) AND (\"ProfileRole\".role = 'SHARER'::\"Role\")))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileListener\"\n  WHERE ((\"ProfileListener\".\"listenerId\" = auth.uid()) AND (\"ProfileListener\".\"sharerId\" IN ( SELECT \"ProfileSharer\".id\n           FROM \"ProfileSharer\"\n          WHERE (\"ProfileSharer\".\"profileId\" = \"Profile\".id)))))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" IN ( SELECT \"ProfileSharer\".id\n           FROM \"ProfileSharer\"\n          WHERE (\"ProfileSharer\".\"profileId\" = \"Profile\".id)))))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileRole\" pr\n  WHERE ((pr.\"profileId\" = \"Profile\".id) AND (pr.role = 'SHARER'::\"Role\")))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Profile",
    "policy_name": "view_requestor_profiles",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid() = id) OR (EXISTS ( SELECT 1\n   FROM (\"FollowRequest\" fr\n     JOIN \"ProfileSharer\" ps ON ((fr.\"sharerId\" = ps.id)))\n  WHERE ((fr.\"requestorId\" = \"Profile\".id) AND (ps.\"profileId\" = auth.uid())))) OR (EXISTS ( SELECT 1\n   FROM \"FollowRequest\" fr\n  WHERE ((fr.\"requestorId\" = auth.uid()) AND (\"Profile\".id IN ( SELECT \"ProfileSharer\".\"profileId\"\n           FROM \"ProfileSharer\"\n          WHERE (\"ProfileSharer\".id = fr.\"sharerId\")))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_admin_direct_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "is_admin()",
    "with_check_expression": "is_admin()"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_admin_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM auth.users\n  WHERE ((users.id = auth.uid()) AND ((users.raw_app_meta_data ->> 'role'::text) = 'admin'::text))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM auth.users\n  WHERE ((users.id = auth.uid()) AND ((users.raw_app_meta_data ->> 'role'::text) = 'admin'::text))))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_owner_direct_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"executorId\" = auth.uid())",
    "with_check_expression": "(\"executorId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_owner_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"executorId\" = auth.uid())",
    "with_check_expression": "(\"executorId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_sharer_direct_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"ProfileExecutor\".\"sharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"ProfileExecutor\".\"sharerId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileExecutor",
    "policy_name": "ProfileExecutor_sharer_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"ProfileExecutor\".\"sharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"ProfileExecutor\".\"sharerId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Executors can manage listener relationships",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (pe.\"sharerId\" = \"ProfileListener\".\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Executors can view listener relationships for their sharer",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (pe.\"sharerId\" = pe.\"sharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Listeners can access their own follow records",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"listenerId\" = auth.uid())",
    "with_check_expression": "(\"listenerId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "ProfileListener_own_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"listenerId\" = auth.uid()))",
    "with_check_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"listenerId\" = auth.uid()))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Sharers can create listener relationships",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"ProfileListener\".\"sharerId\")))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Sharers can view their followers",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(\"sharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Users can manage listener relationships",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"ProfileListener\".\"sharerId\")))",
    "with_check_expression": "(auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"ProfileListener\".\"sharerId\")))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileListener",
    "policy_name": "Users can view listener relationships",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"ProfileListener\".\"sharerId\"))) OR (auth.uid() = \"listenerId\"))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Admins can do anything",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "is_admin(auth.uid())",
    "with_check_expression": "is_admin(auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "ProfileRole_delete_policy",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"profileId\" = auth.uid()))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "ProfileRole_insert_policy",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"profileId\" = auth.uid()))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "ProfileRole_select_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"profileId\" = auth.uid()))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "ProfileRole_update_policy",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"profileId\" = auth.uid()))",
    "with_check_expression": "((( SELECT p.\"isAdmin\"\n   FROM \"Profile\" p\n  WHERE (p.id = auth.uid())) = true) OR (\"profileId\" = auth.uid()))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Users can delete own roles",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() = \"profileId\")",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Users can insert own roles",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(auth.uid() = \"profileId\")"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Users can update own roles",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() = \"profileId\")",
    "with_check_expression": "(auth.uid() = \"profileId\")"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Users can view own roles",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() = \"profileId\")",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "Users can view their own profile roles",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(\"profileId\" = auth.uid())",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "allow_sharer_role_visibility",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(role = 'SHARER'::\"Role\")",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileRole",
    "policy_name": "prevent_self_admin_elevation",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((role <> 'ADMIN'::\"Role\") OR (( SELECT auth.uid() AS uid) <> \"profileId\"))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_admin_direct_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "is_admin()",
    "with_check_expression": "is_admin()"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_admin_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM auth.users\n  WHERE ((users.id = auth.uid()) AND ((users.raw_app_meta_data ->> 'role'::text) = 'admin'::text))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM auth.users\n  WHERE ((users.id = auth.uid()) AND ((users.raw_app_meta_data ->> 'role'::text) = 'admin'::text))))"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_executor_direct_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"sharerId\" = \"ProfileSharer\".id) AND (pe.\"executorId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_executor_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\" pe\n  WHERE ((pe.\"sharerId\" = \"ProfileSharer\".id) AND (pe.\"executorId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_owner_direct_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileId\" = auth.uid())",
    "with_check_expression": "(\"profileId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ProfileSharer",
    "policy_name": "ProfileSharer_owner_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileId\" = auth.uid())",
    "with_check_expression": "(\"profileId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "Prompt",
    "policy_name": "Allow SELECT on prompts to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Prompt",
    "policy_name": "Anyone can view prompts",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Prompt",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptCategory",
    "policy_name": "Allow SELECT on prompt categories to all users",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptCategory",
    "policy_name": "Anyone can view prompt categories",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "true",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptCategory",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Executors can delete sharer's responses",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Executors can insert sharer's responses",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Executors can manage prompt responses",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"PromptResponse\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Executors can update sharer's responses",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\"))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Executors can view sharer's responses",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Listeners can view prompt responses from sharers they follow",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((EXISTS ( SELECT 1\n   FROM \"ProfileListener\" pl\n  WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = \"PromptResponse\".\"profileSharerId\") AND (pl.\"hasAccess\" = true)))) AND (\"privacyLevel\" = 'Public'::text))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "PromptResponse_manage_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "has_sharer_access(\"profileSharerId\")",
    "with_check_expression": "has_sharer_access(\"profileSharerId\")"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Service role can manage all prompt responses",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Sharers can access their own prompt responses",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))",
    "with_check_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Users can manage own prompt responses",
    "command_type": "ALL",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"PromptResponse\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"PromptResponse\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Users can manage prompt responses",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"PromptResponse\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\")))))",
    "with_check_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"PromptResponse\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\")))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Users can view own prompt responses",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"PromptResponse\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponse",
    "policy_name": "Users can view prompt responses",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"PromptResponse\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\")))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileListener\"\n  WHERE ((\"ProfileListener\".\"listenerId\" = auth.uid()) AND (\"ProfileListener\".\"sharerId\" = \"PromptResponse\".\"profileSharerId\") AND (\"ProfileListener\".\"hasAccess\" = true)))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Allow promptResponseAttachment inserts for owners",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "(\"profileSharerId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Executors can delete sharer's attachments",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Executors can insert sharer's attachments",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Executors can manage prompt response attachments",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Executors can update sharer's attachments",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Executors can view sharer's attachments",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"PromptResponseAttachment\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Listeners can view attachments from accessible prompt responses",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"PromptResponse\" pr\n  WHERE ((pr.id = \"PromptResponseAttachment\".\"promptResponseId\") AND (pr.\"privacyLevel\" = 'Public'::text) AND (EXISTS ( SELECT 1\n           FROM \"ProfileListener\" pl\n          WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = pr.\"profileSharerId\") AND (pl.\"hasAccess\" = true)))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "Sharers can access their own attachments",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))",
    "with_check_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachment",
    "policy_name": "service_role_bypass",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachmentPersonTag",
    "policy_name": "Executors can manage prompt response attachment person tags",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"PromptResponseAttachment\" pra\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"executorId\" = auth.uid())))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (ps.\"profileId\" = pra.\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachmentPersonTag",
    "policy_name": "PromptResponseAttachmentPersonTag_admin_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "is_admin()",
    "with_check_expression": "is_admin()"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachmentPersonTag",
    "policy_name": "PromptResponseAttachmentPersonTag_executor_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"PromptResponseAttachment\" pra\n     JOIN \"PromptResponse\" pr ON ((pr.id = pra.\"promptResponseId\")))\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"sharerId\" = pr.\"profileSharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (pe.\"executorId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM ((\"PromptResponseAttachment\" pra\n     JOIN \"PromptResponse\" pr ON ((pr.id = pra.\"promptResponseId\")))\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"sharerId\" = pr.\"profileSharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (pe.\"executorId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachmentPersonTag",
    "policy_name": "PromptResponseAttachmentPersonTag_sharer_policy",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"PromptResponseAttachment\" pra\n     JOIN \"PromptResponse\" pr ON ((pr.id = pra.\"promptResponseId\")))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pr.\"profileSharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM ((\"PromptResponseAttachment\" pra\n     JOIN \"PromptResponse\" pr ON ((pr.id = pra.\"promptResponseId\")))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pr.\"profileSharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseAttachmentPersonTag",
    "policy_name": "Sharers can manage their own prompt response attachment person ",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"PromptResponseAttachment\" pra\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pra.\"profileSharerId\")))\n  WHERE ((pra.id = \"PromptResponseAttachmentPersonTag\".\"promptResponseAttachmentId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseFavorite",
    "policy_name": "Users can access their own favorites",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileId\" = auth.uid())",
    "with_check_expression": "(\"profileId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "PromptResponseRecentlyWatched",
    "policy_name": "Users can access their own recently watched records",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileId\" = auth.uid())",
    "with_check_expression": "(\"profileId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "Purchase",
    "policy_name": "Users can access their own purchases",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"userId\" = auth.uid())",
    "with_check_expression": "(\"userId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "ResponsePermission",
    "policy_name": "Sharers can delete permissions for their responses",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"ResponsePermission\".\"responseId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "ResponsePermission",
    "policy_name": "Sharers can insert permissions for their responses",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"ResponsePermission\".\"responseId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "ResponsePermission",
    "policy_name": "Sharers can update permissions for their responses",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"ResponsePermission\".\"responseId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"PromptResponse\" pr\n     JOIN \"ProfileSharer\" ps ON ((pr.\"profileSharerId\" = ps.id)))\n  WHERE ((pr.id = \"ResponsePermission\".\"responseId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "ResponsePermission",
    "policy_name": "Users can access their own response permissions",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(\"userId\" = auth.uid())",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Subscription",
    "policy_name": "Users can access their own subscriptions",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"userId\" = auth.uid())",
    "with_check_expression": "(\"userId\" = auth.uid())"
  },
  {
    "schema_name": "public",
    "table_name": "SubscriptionEntitlement",
    "policy_name": "Users can access their own subscription entitlements",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"Subscription\" s\n  WHERE ((s.id = \"SubscriptionEntitlement\".\"subscriptionId\") AND (s.\"userId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"Subscription\" s\n  WHERE ((s.id = \"SubscriptionEntitlement\".\"subscriptionId\") AND (s.\"userId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "Executors can manage topic favorites",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"TopicFavorite\".\"profileId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "users_can_delete_own_favorites",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid())::text = (\"profileId\")::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "users_can_insert_own_favorites",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "((auth.uid())::text = (\"profileId\")::text)"
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "users_can_read_own_favorites",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid())::text = (\"profileId\")::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicFavorite",
    "policy_name": "users_can_view_own_favorites",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(((role = 'SHARER'::text) AND (EXISTS ( SELECT 1\n   FROM \"ProfileSharer\"\n  WHERE ((\"ProfileSharer\".id = \"TopicFavorite\".\"sharerId\") AND (\"ProfileSharer\".\"profileId\" = auth.uid()))))) OR ((role = 'EXECUTOR'::text) AND (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".id = \"ProfileExecutor\".\"executorId\") AND (\"ProfileExecutor\".\"executorId\" = auth.uid()))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicQueueItem",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "TopicQueueItem",
    "policy_name": "Executors can manage topic queue items",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"TopicQueueItem\".\"profileId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicQueueItem",
    "policy_name": "users_can_delete_own_queue_items",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid())::text = (\"profileId\")::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicQueueItem",
    "policy_name": "users_can_insert_own_queue_items",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "((auth.uid())::text = (\"profileId\")::text)"
  },
  {
    "schema_name": "public",
    "table_name": "TopicQueueItem",
    "policy_name": "users_can_read_own_queue_items",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((auth.uid())::text = (\"profileId\")::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "Executors can manage topic videos",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"TopicVideo\".\"profileSharerId\"))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"TopicVideo\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "Service role can manage all topic videos",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "Users can manage own topic videos",
    "command_type": "ALL",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"TopicVideo\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"TopicVideo\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "Users can view own topic videos",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"TopicVideo\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "topicvideo_insert_policy",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.\"profileId\" = auth.uid()) AND (ps.id = \"TopicVideo\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "topicvideo_select_policy",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.\"profileId\" = auth.uid()) AND (ps.id = \"TopicVideo\".\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideo",
    "policy_name": "topicvideo_update_policy",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.\"profileId\" = auth.uid()) AND (ps.id = \"TopicVideo\".\"profileSharerId\"))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.\"profileId\" = auth.uid()) AND (ps.id = \"TopicVideo\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoDownload",
    "policy_name": "Executors can manage topic video downloads",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"TopicVideo\" tv\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"executorId\" = auth.uid())))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((tv.\"muxAssetId\" = \"TopicVideoDownload\".\"muxAssetId\") AND (ps.\"profileId\" = tv.\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoTranscript",
    "policy_name": "Allow service role full access on TopicVideoTranscript",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoTranscript",
    "policy_name": "Allow users to manage their own topic video transcripts",
    "command_type": "ALL",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"TopicVideo\" tv\n     JOIN \"ProfileSharer\" ps ON ((tv.\"profileSharerId\" = ps.id)))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"TopicVideo\" tv\n     JOIN \"ProfileSharer\" ps ON ((tv.\"profileSharerId\" = ps.id)))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoTranscript",
    "policy_name": "Allow users to update their own topic video transcripts",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"TopicVideo\" tv\n     JOIN \"ProfileSharer\" ps ON ((tv.\"profileSharerId\" = ps.id)))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"TopicVideo\" tv\n     JOIN \"ProfileSharer\" ps ON ((tv.\"profileSharerId\" = ps.id)))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = auth.uid()))))"
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoTranscript",
    "policy_name": "Allow users to view their own topic video transcripts",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"TopicVideo\" tv\n     JOIN \"ProfileSharer\" ps ON ((tv.\"profileSharerId\" = ps.id)))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "TopicVideoTranscript",
    "policy_name": "Executors can manage topic video transcripts",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"TopicVideo\" tv\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"executorId\" = auth.uid())))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((tv.id = \"TopicVideoTranscript\".\"topicVideoId\") AND (ps.\"profileId\" = tv.\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Enable all for service role",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Executors can manage videos",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"Video\".\"profileSharerId\"))))",
    "with_check_expression": "(EXISTS ( SELECT 1\n   FROM (\"ProfileExecutor\" pe\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((pe.\"executorId\" = auth.uid()) AND (ps.\"profileId\" = \"Video\".\"profileSharerId\"))))"
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Listeners can view videos from sharers they follow",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileListener\" pl\n  WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = \"Video\".\"profileSharerId\") AND (pl.\"hasAccess\" = true))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Service role can manage all videos",
    "command_type": "ALL",
    "policy_roles": "{service_role}",
    "using_expression": "true",
    "with_check_expression": "true"
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Sharers can access their own videos",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))",
    "with_check_expression": "(\"profileSharerId\" = ( SELECT \"ProfileSharer\".id\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".\"profileId\" = auth.uid())))"
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Users can manage own videos",
    "command_type": "ALL",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"Video\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Users can manage videos",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Video\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"Video\".\"profileSharerId\")))))",
    "with_check_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Video\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"Video\".\"profileSharerId\")))))"
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Users can view own videos",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM \"ProfileSharer\" ps\n  WHERE ((ps.id = \"Video\".\"profileSharerId\") AND (ps.\"profileId\" = auth.uid()))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "Video",
    "policy_name": "Users can view videos",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.uid() IN ( SELECT \"ProfileSharer\".\"profileId\"\n   FROM \"ProfileSharer\"\n  WHERE (\"ProfileSharer\".id = \"Video\".\"profileSharerId\"))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileExecutor\"\n  WHERE ((\"ProfileExecutor\".\"executorId\" = auth.uid()) AND (\"ProfileExecutor\".\"sharerId\" = \"Video\".\"profileSharerId\")))) OR (EXISTS ( SELECT 1\n   FROM \"ProfileListener\"\n  WHERE ((\"ProfileListener\".\"listenerId\" = auth.uid()) AND (\"ProfileListener\".\"sharerId\" = \"Video\".\"profileSharerId\") AND (\"ProfileListener\".\"hasAccess\" = true)))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "VideoDownload",
    "policy_name": "Executors can manage video downloads",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"Video\" v\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"executorId\" = auth.uid())))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((v.\"muxAssetId\" = \"VideoDownload\".\"muxAssetId\") AND (ps.\"profileId\" = v.\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "VideoDownload",
    "policy_name": "Users can create their own downloads",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "(auth.uid() = \"profileId\")"
  },
  {
    "schema_name": "public",
    "table_name": "VideoDownload",
    "policy_name": "Users can view their own downloads",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "(auth.uid() = \"profileId\")",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "VideoTranscript",
    "policy_name": "Executors can manage video transcripts",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(EXISTS ( SELECT 1\n   FROM ((\"Video\" v\n     JOIN \"ProfileExecutor\" pe ON ((pe.\"executorId\" = auth.uid())))\n     JOIN \"ProfileSharer\" ps ON ((ps.id = pe.\"sharerId\")))\n  WHERE ((v.id = \"VideoTranscript\".\"videoId\") AND (ps.\"profileId\" = v.\"profileSharerId\"))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "VideoTranscript",
    "policy_name": "Listeners can view transcripts of accessible videos",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((auth.role() = 'service_role'::text) OR (EXISTS ( SELECT 1\n   FROM \"Video\" v\n  WHERE ((v.id = \"VideoTranscript\".\"videoId\") AND (EXISTS ( SELECT 1\n           FROM \"ProfileListener\" pl\n          WHERE ((pl.\"listenerId\" = auth.uid()) AND (pl.\"sharerId\" = v.\"profileSharerId\") AND (pl.\"hasAccess\" = true))))))))",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "VideoTranscript",
    "policy_name": "Sharers can access their own video transcripts",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "((auth.role() = 'service_role'::text) OR (EXISTS ( SELECT 1\n   FROM (\"Video\" v\n     JOIN \"ProfileSharer\" ps ON ((v.\"profileSharerId\" = ps.id)))\n  WHERE ((v.id = \"VideoTranscript\".\"videoId\") AND (ps.\"profileId\" = auth.uid())))))",
    "with_check_expression": "((auth.role() = 'service_role'::text) OR (EXISTS ( SELECT 1\n   FROM (\"Video\" v\n     JOIN \"ProfileSharer\" ps ON ((v.\"profileSharerId\" = ps.id)))\n  WHERE ((v.id = \"VideoTranscript\".\"videoId\") AND (ps.\"profileId\" = auth.uid())))))"
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerPromptViews",
    "policy_name": "allow_delete_listenerpromptviews_admin",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerPromptViews",
    "policy_name": "allow_insert_listenerpromptviews_admin",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerPromptViews",
    "policy_name": "allow_select_listenerpromptviews_authenticated",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() IS NOT NULL)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerPromptViews",
    "policy_name": "allow_update_listenerpromptviews_admin",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerVideoViews",
    "policy_name": "allow_delete_listenervideoviews_admin",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerVideoViews",
    "policy_name": "allow_insert_listenervideoviews_admin",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerVideoViews",
    "policy_name": "allow_select_listenervideoviews_authenticated",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() IS NOT NULL)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_ListenerVideoViews",
    "policy_name": "allow_update_listenervideoviews_admin",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_PromptResponseToThematicVideo",
    "policy_name": "allow_delete_promptresponsetothematicvideo_admin",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_PromptResponseToThematicVideo",
    "policy_name": "allow_insert_promptresponsetothematicvideo_admin",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_PromptResponseToThematicVideo",
    "policy_name": "allow_select_promptresponsetothematicvideo_authenticated",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(auth.uid() IS NOT NULL)",
    "with_check_expression": null
  },
  {
    "schema_name": "public",
    "table_name": "_PromptResponseToThematicVideo",
    "policy_name": "allow_update_promptresponsetothematicvideo_admin",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "public",
    "table_name": "_prisma_migrations",
    "policy_name": "allow_all_prisma_migrations_admin",
    "command_type": "ALL",
    "policy_roles": "{public}",
    "using_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)",
    "with_check_expression": "(current_setting('jwt.claims.role'::text, true) = 'admin'::text)"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Allow authenticated deletes",
    "command_type": "DELETE",
    "policy_roles": "{authenticated}",
    "using_expression": "((bucket_id = 'attachments'::text) AND (auth.role() = 'authenticated'::text))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Allow authenticated reads",
    "command_type": "SELECT",
    "policy_roles": "{authenticated}",
    "using_expression": "((bucket_id = 'attachments'::text) AND (auth.role() = 'authenticated'::text))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Allow authenticated updates",
    "command_type": "UPDATE",
    "policy_roles": "{authenticated}",
    "using_expression": "((bucket_id = 'attachments'::text) AND (auth.role() = 'authenticated'::text))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Allow authenticated uploads",
    "command_type": "INSERT",
    "policy_roles": "{authenticated}",
    "using_expression": null,
    "with_check_expression": "((bucket_id = 'attachments'::text) AND (auth.role() = 'authenticated'::text))"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Anyone can upload an avatar.",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "(bucket_id = 'avatars'::text)"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Attachments are publicly accessible.",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(bucket_id = 'attachments'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Authenticated users can upload attachments.",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((bucket_id = 'attachments'::text) AND (auth.role() = 'authenticated'::text))"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Avatar images are publicly accessible.",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(bucket_id = 'avatars'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Users can delete their own attachments.",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((bucket_id = 'attachments'::text) AND (auth.uid() = owner))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Users can delete their own avatar",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((bucket_id = 'avatars'::text) AND ((auth.uid())::text = split_part(name, '/'::text, 1)))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Users can update their own attachments.",
    "command_type": "UPDATE",
    "policy_roles": "{public}",
    "using_expression": "((bucket_id = 'attachments'::text) AND (auth.uid() = owner))",
    "with_check_expression": "(bucket_id = 'attachments'::text)"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "Users can upload their own avatar",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((bucket_id = 'avatars'::text) AND ((auth.uid())::text = split_part(name, '/'::text, 1)))"
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "authed read access",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "(bucket_id = 'avatars'::text)",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "authenticated read access to avatars",
    "command_type": "SELECT",
    "policy_roles": "{public}",
    "using_expression": "((bucket_id = 'avatars'::text) AND (auth.role() = 'authenticated'::text))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "users can delete their own avatar",
    "command_type": "DELETE",
    "policy_roles": "{public}",
    "using_expression": "((bucket_id = 'avatars'::text) AND (auth.uid() = (split_part(name, '/'::text, 1))::uuid))",
    "with_check_expression": null
  },
  {
    "schema_name": "storage",
    "table_name": "objects",
    "policy_name": "users can upload their own avatar",
    "command_type": "INSERT",
    "policy_roles": "{public}",
    "using_expression": null,
    "with_check_expression": "((bucket_id = 'avatars'::text) AND (auth.uid() = (split_part(name, '/'::text, 1))::uuid))"
  }
]